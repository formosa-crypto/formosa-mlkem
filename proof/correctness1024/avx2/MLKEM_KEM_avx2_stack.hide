require import AllCore IntDiv List.

from JazzEC require import Jkem1024_avx2.
from Jasmin require import JModel_x86.
from JazzEC require import Array32 Array64 Array396 Array196 Array1408 Array160 Array128 Array1120 Array1600 Array1536 Array1568 Array3168.
from JazzEC require import Array4 Array8 Array300 WArray32 WArray64 WArray1600 WArray1120 WArray1568 WArray3168.

from CryptoSpecs require import MLKEM1024 Symmetric.
import Symmetric1024.

require import MLKEM_KEM_avx2.
require import MLKEM_InnerPKE_avx2.

require import MLKEM_keccak_avx2.


lemma copy32 (a : W8.t Array32.t) :
Array32.init (fun (i : int)  =>  WArray32.get8 (WArray32.init64                                                                                    
             (fun (i0 : int) =>  copy_64 (Array4.init                                                                             
             (fun (i1 : int) =>  WArray32.get64 (WArray32.init8                                                                  
             (fun (i2 : int) =>  a.[i2]))  i1)).[i0])) i) = a.             
proof.
rewrite tP => k kb.
rewrite initiE 1:/# /= /get8.
rewrite initiE 1:/# /= /copy_64.
rewrite initiE 1:/# /= /get64_direct.
rewrite W8u8.pack8bE 1:/# /=.
rewrite initiE 1:/# /=.
rewrite initiE /#.
qed.

lemma copy64 (a : W8.t Array64.t) :
Array64.init (fun (i : int)  =>  WArray64.get8 (WArray64.init64                                                                                    
             (fun (i0 : int) =>  copy_64 (Array8.init                                                                             
             (fun (i1 : int) =>  WArray64.get64 (WArray64.init8                                                                  
             (fun (i2 : int) =>  a.[i2]))  i1)).[i0])) i) = a.                                                               
proof. 
rewrite tP => k kb.
rewrite initiE 1:/# /= /get8.
rewrite initiE 1:/# /= /copy_64.
rewrite initiE 1:/# /= /get64_direct.
rewrite W8u8.pack8bE 1:/# /=.
rewrite initiE 1:/# /=.
rewrite initiE /#.
qed.

lemma copy1568 (a : W8.t Array1568.t) :
Array1568.init (fun (i : int)  =>  WArray1568.get8 (WArray1568.init64                                                                       
               (fun (i0 : int) =>  copy_64 (Array196.init                                                                             
               (fun (i1 : int) =>  WArray1568.get64 (WArray1568.init8                                                                  
               (fun (i2 : int) =>  a.[i2]))  i1)).[i0])) i) = a.  
rewrite tP => k kb.
rewrite initiE 1:/# /= /get8.
rewrite initiE 1:/# /= /copy_64.
rewrite initiE 1:/# /= /get64_direct.
rewrite W8u8.pack8bE 1:/# /=.
rewrite initiE 1:/# /=.
rewrite initiE /#.
qed.

lemma copy3168 (a : W8.t Array3168.t) :
Array3168.init (fun (i : int)  =>  WArray3168.get8 (WArray3168.init64                                                                       
               (fun (i0 : int) =>  copy_64 (Array396.init                                                                             
               (fun (i1 : int) =>  WArray3168.get64 (WArray3168.init8                                                                  
               (fun (i2 : int) =>  a.[i2]))  i1)).[i0])) i) = a.                    rewrite tP => k kb.
rewrite initiE 1:/# /= /get8.
rewrite initiE 1:/# /= /copy_64.
rewrite initiE 1:/# /= /get64_direct.
rewrite W8u8.pack8bE 1:/# /=.
rewrite initiE 1:/# /=.
rewrite initiE /#.
qed.

lemma mlkem_kem_correct_kg   : 
   equiv [Jkem1024_avx2.M.jade_kem_mlkem_mlkem1024_amd64_avx2_keypair_derand ~ MLKEM1024.kg_derand : 
        coins{2}.`1 = Array32.init(fun i => coins{1}.[i]) /\
        coins{2}.`2 = Array32.init(fun i => coins{1}.[32 + i]) 
        ==> 
       let (pk,sk) = res{2} in let (t,rho) = pk in
         sk.`1 = Array1536.init(fun i => res{1}.`2.[i])  /\
         sk.`2.`1 = Array1536.init(fun i => res{1}.`2.[i+1536]) /\
         sk.`2.`2 = Array32.init(fun i => res{1}.`2.[i+1536+1536]) /\
         sk.`3 = Array32.init(fun i => res{1}.`2.[i+1536+1536 + 32]) /\
         sk.`4 = Array32.init(fun i => res{1}.`2.[i+1536+1536 + 32 + 32]) /\
         t = Array1536.init(fun i => res{1}.`1.[i]) /\  
         rho = Array32.init(fun i => res{1}.`1.[i+1536])].
proof.
proc => /=.
proc rewrite {1} 8 (copy64).
proc rewrite {1} 16 (copy1568).
proc rewrite {1} 17 (copy3168).
sp;wp;inline {1} 1.

sp 3 0; seq 6 0 : #pre;1: by auto.
wp;sp 1 0.

seq 11 1 : (
      z{2} = coins{2}.`2 /\
      coins{2}.`2 = (init (fun (i0 : int) => s_randomnessp{1}.[32 + i0]))%Array32  /\
      sk{2} = Array1536.init (fun i => sk0{1}.[i]) /\
      pk{2}.`1 = Array1536.init (fun i => sk0{1}.[i+1536]) /\
      pk{2}.`2 = Array32.init (fun i => sk0{1}.[i + 1536 + 1536]) /\
      H_pk pk{2} = Array32.init (fun i => sk0{1}.[i + 1536 + 1536 + 32]) /\
      pk{2}.`1 = Array1536.init (fun i => pk0{1}.[i]) /\
      pk{2}.`2 = Array32.init (fun i => pk0{1}.[i + 1536]) 
); last first.
+ while {1} (inc{1} = 4 /\
      coins{2}.`2 = randomnessp2{1} /\
      sk{2} = Array1536.init (fun i => sk0{1}.[i]) /\
      pk{2}.`1 = Array1536.init (fun i => sk0{1}.[i+1536]) /\
      pk{2}.`2 = Array32.init (fun i => sk0{1}.[i + 1536 + 1536]) /\
      H_pk pk{2} = Array32.init (fun i => sk0{1}.[i + 1536 + 1536 + 32]) /\
      pk{2}.`1 = Array1536.init (fun i => pk0{1}.[i]) /\
      pk{2}.`2 = Array32.init (fun i => pk0{1}.[i + 1536]) /\
       0 <= i{1} <= 4 /\ 
       forall k, 0<=k<i{1} => 
          WArray3168.get64_direct (WArray3168.init 
            (fun ii => sk0{1}.[ii])) (3136 + k*8) =  
                pack8_t (W8u8.Pack.init (fun ii => coins{2}.`2.[k*8+ii])))
          (4 - i{1}).
  + move => &m z0; auto => /> &hr; rewrite !tP => 
       ???????prev?.
    do split;5..6,8..:smt().
    + move => i ib;rewrite initiE 1:/# initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ((392 + i{!hr}) * 8 <= i && i < (392 + i{!hr}) * 8 + 8 ) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE /#.
    + move => i ib;rewrite initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.

      case ((392 + i{!hr}) * 8 <= i + 1536 && i + 1536 < (392 + i{!hr}) * 8 + 8)  => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE 1:/# /=;smt(Array1536.initiE).
    + move => i ib;rewrite initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((392 + i{!hr}) * 8 <= i + 3072 && i + 3072 < (392 + i{!hr}) * 8 + 8)  => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE 1:/# /=; smt(Array32.initiE).
    + move => i ib; pose xx := H_pk pk{m}. 
      rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.

      case  ((392 + i{!hr}) * 8 <= i + 3104 && i + 3104 < (392 + i{!hr}) * 8 + 8) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array32.initiE).
     + move => ii iibl iibh.
       rewrite /get64_direct (inj_eq W8u8.pack8_t pack_inj) packP => k kh.
       rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
       rewrite initiE 1:/# /=.
       rewrite get8_set64_directE 1,2:/# /=.

      case  ( (392 + i{hr}) * 8 <= 3136 + ii * 8 + k && 3 + ii * 8 + k < (392 + i{hr}) * 8 + 8) => *.
      + rewrite  pack8bE 1:/# initiE 1:/# /= initiE 1: /# /=.
        by   smt(Array32.initiE). 
      move : (prev ii _);1:by smt().
      rewrite /get64_direct (inj_eq W8u8.pack8_t pack_inj) packP => Hii.
      move: (Hii k _); first smt().
      rewrite !initiE 1..2:/# /= => <-.
      by rewrite /get8 !initiE /#.

auto =>/> &1 &2 *;do split. 
     + move => ii iibl iibh.
       rewrite /get64_direct (inj_eq W8u8.pack8_t pack_inj) packP => k kh.
       by rewrite initiE 1:/# /= initiE 1:/# /= initiE /#.
     move => i1 sk0; do split =>???????H;1:smt(). 
     + move => rho t?; rewrite tP => k kb.
      move : (H (k %/ 8) _);1:smt().
      rewrite /get64_direct (inj_eq W8u8.pack8_t pack_inj) packP => Hkk.
      move : (Hkk (k %% 8) _); 1: smt().
       rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      + by rewrite initiE /#.

wp;conseq (_: _ ==>
      sk{2} = Array1536.init (fun i => sk0{1}.[i]) /\
      pk{2}.`1 = Array1536.init (fun i => sk0{1}.[i+1536]) /\
      pk{2}.`2 = Array32.init (fun i => sk0{1}.[i + 1536 + 1536]) /\
      H_pk pk{2} = Array32.init (fun i => sk0{1}.[i + 1536 + 1536 + 32]) /\
      pk{2}.`1 = Array1536.init (fun i => pk0{1}.[i]) /\
      pk{2}.`2 = Array32.init (fun i => pk0{1}.[i + 1536]) 
); 1: by auto.

seq 2 1 : (
      sk{2} = Array1536.init (fun i => sk0{1}.[i]) /\
      pk{2}.`1 = Array1536.init (fun i => pk0{1}.[i]) /\
      pk{2}.`2 = Array32.init (fun i => pk0{1}.[i + 1536])). 
call (mlkem_correct_kg_avx2).
auto => /> /#. 

swap {1} 1 8. swap {1} 4 1.
seq 3 0 : (#pre /\
      sk{2} = Array1536.init (fun i => sk0{1}.[i]) /\
      pk{2}.`1 = Array1536.init (fun i => sk0{1}.[i+1536]) /\
      pk{2}.`2 = Array32.init (fun i => sk0{1}.[i + 1536 + 1536]) /\
      pk{2}.`1 = Array1536.init (fun i => pk0{1}.[i]) /\
      pk{2}.`2 = Array32.init (fun i => pk0{1}.[i + 1536]) 
).

+ wp;while {1} (#pre /\ 
    inc{1} = (4 * 384 + 32) %/ 8 /\ 0<=i{1} <= inc{1} /\
    (forall k, 0<= k < min (8 * i{1}) 1536  => 
         pk{2}.`1.[k] = sk0{1}.[1536+k]) /\
    (forall k, 1536 <= k < min (8 * i{1}) (1536 + 32) => 
         pk{2}.`2.[k-1536] = sk0{1}.[1536 + k]))
    ((4 * 384 + 32) %/ 8 - i{1}).
  move => &m z;auto => /> &hr; rewrite !tP.
  move => pkv1 pkv2???prev1 prev2.
  do split.
  +  move => i ib; rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((192 + i{!hr}) * 8 <= i && i < (192 + i{!hr}) * 8 + 8) => *.
      + by rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array32.initiE).
  + by smt().
  + by smt().
  +  move => i ib ibb; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ((192 + i{!hr}) * 8 <= 1536 + i && 1536 + i < (192 + i{!hr}) * 8 + 8) => *.
      + rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /=.
      by rewrite /get8 initiE; smt(Array1536.initiE).
    + by rewrite /get8 initiE; smt(Array1536.initiE).
  +  move => i ib ibb; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ( (192 + i{!hr}) * 8 <= 1536 + i && 1536 + i < (192 + i{!hr}) * 8 + 8) => *.
      + rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /=.
      by rewrite /get8 initiE 1:/#;  smt(Array32.initiE).
    + by rewrite /get8 initiE; smt(Array1536.initiE).
  + by smt().

  auto => /> &1 &2; rewrite !tP.
  move =>  ??.
  do split; 1..2: by smt(). 
  move => il skl.
  rewrite !tP; split; 1: smt().
  move => ??????; do split. 
  + by move => *; rewrite initiE //= /#.
  by move => *; rewrite initiE //= /#.
   
seq 1 0 : (#pre /\  h_pk{1} = H_pk pk{2}).

ecall {1} (sha3_256A_M1568_ph pk0{1}); 1: by inline *; auto => />* /#.  

wp;while {1} (#pre /\ 
         0 <= i{1} <= 4 /\ 
         forall k, 0 <= k < i{1} * 8 => sk0{1}.[3104 + k] = ((H_pk pk{2})).[k]) (4 - i{1}).
move => &m z; auto => /> &1 &2; rewrite  !tP.
move => pkv1s pkv2s pkv1 pkv2 ? prev ?;do split.
  +  move => i ib; rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((388 + i{!1}) * 8 <= i && i < (388 + i{!1}) * 8 + 8) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array3168.initiE).
  +  move => i ib; rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((388 + i{!1}) * 8 <= i && i < (388 + i{!1}) * 8 + 8) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array3168.initiE).
  +  move => i ib; rewrite initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((388 + i{!1}) * 8 <= i + 1536 && i + 1536 < (388 + i{!1}) * 8 + 8) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array1536.initiE).
  +  move => i ib; rewrite initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((288 + i{!1}) * 8 <= i + 3072 && i + 3072 < (288 + i{!1}) * 8 + 8) => *.
      + by rewrite WArray32.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array32.initiE).
  + by smt().
  + by smt().
  +  move => i ib ibb; 
      rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ( (388 + i{!1}) * 8 <= 3104 + i && 3104 + i < (388 + i{!1}) * 8 + 8) => *.
      + rewrite WArray32.get64E pack8bE 1:/# initiE 1:/#.
      rewrite /get8 initiE 1:/# /= initiE 1:/# /=.
      by rewrite /H_pk /SHA3_256_1568_32 /= get_of_list /#.
    + by rewrite /get8 initiE; smt(Array1536.initiE).
  + by smt().


auto => /> &1 &2; rewrite !tP => *; split; 1: smt().
move => i ib *;do split;1:smt().
by move => *;rewrite tP => k kb; smt(Array32.initiE).
qed.


lemma mlkem_kem_correct_enc : 
   equiv [Jkem1024_avx2.M.jade_kem_mlkem_mlkem1024_amd64_avx2_enc_derand ~ MLKEM1024.enc_derand: 
     coins{1} = coins{2} /\
     pk{2}.`1 = Array1536.init(fun i => public_key{1}.[i])  /\
     pk{2}.`2 = Array32.init(fun i => public_key{1}.[i+1536])
       ==> 
     let (c,k) = res{2} in
     c.`1 = Array1408.init(fun i => res{1}.`1.[i]) /\
     c.`2 = Array160.init(fun i => res{1}.`1.[i+1408])  /\
     k = res{1}.`2
].
proc => //=.
proc rewrite {1} 10 (copy1568).
proc rewrite {1} 11 (copy32).
proc rewrite {1} 21 (copy1568).
proc rewrite {1} 22 (copy32).
inline {1} 16. 
swap {1} [9..19] 5. 
seq 13 0 : #pre; 1: by auto.
sp 14 0;wp.
seq 9 4 : (#[/1:-2]post  /\  
      (forall k, 0<=k<32 => kr{1}.[k]=_K{2}.[k])); last first.
+ wp;conseq />. while {1} (
        inc{1} = 4 
      /\ 0<=i{1}<=4 
      /\ (forall k, 0<=k<32 => kr{1}.[k]=_K{2}.[k])
      /\ (forall k, 0<=k<8*i{1} =>  _K{2}.[k] = shk0{1}.[k])) (inc{1} - i{1}).
  + auto => /> &hr H H0 H1 H2 H3;do split;1,2,4:smt().
  +  move => k kb kbh; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  (8 * i{hr} <= k && k < 8 * i{hr} + 8 ) => *.
      + rewrite WArray64.get64E pack8bE 1:/# initiE 1:/# /= initiE /= 1:/#. by smt().
      by rewrite /get8 initiE; smt(Array32.initiE).

  auto => /> &1 &2;rewrite !tP => *;do split. 
  + move => *; smt(Array1408.initiE).
  + move => *; do split;1:smt().
  by move => *; smt(Array32.tP).

wp; call (mlkem_correct_enc_avx2).
wp; ecall {1} (sha3_512A_512A_A64 coins{2} (H_pk pk{2})).
wp; ecall {1} (sha3_256A_M1568_ph pk0{1}).
seq 3 0 : (#pre /\  randomnessp{1} = Array32.init (fun i => buf{1}.[i])).
+ sp ; conseq />.
  while {1} (0<=i{1}<=inc{1} /\ inc{1} = 4 /\ randomnessp{1} = coins{2} /\  (forall k, 0<=k<i{1}*8 => randomnessp{1}.[k] = buf{1}.[k])) (inc{1} - i{1}); last first.
  + auto => /> &1 &2 *; split; 1: by smt().  
    move => buf i1; split; 1: smt(). 
    by move => *; rewrite tP => k kn; rewrite initiE //= /#. 
  move => &2 ?.
  auto => /> &1 il ih premv ihh; do split; 1,2,4:smt().
  move => k kl kh; rewrite initiE 1:/# /=.
  rewrite WArray64.get8_set64_directE 1..2:/#.
  case (8 * i{1} <= k && k < 8 * i{1} + 8).
  + move => *. 
     rewrite WArray32.get64E pack8bE 1:/# !initiE 1:/# /= /init8.  
     by rewrite !WArray32.initiE /#.
  by move => *; rewrite /get8; rewrite WArray64.initiE /#.
auto  => /> &1 &2.
move => [#] pkv1 pkv2; do split.
+ by rewrite tP => i ib; rewrite !initiE /= /#.
+ rewrite tP => i ib; rewrite initiE /= 1:/# initiE /= 1:/# /=. 
  rewrite initiE 1:/# /= initiE 1:/# /= ifT 1:/#. 
  by congr;congr;congr;congr;smt().

rewrite !tP => H H0 rr0 H1 H2;do split.
+ by move => i ib;rewrite -pkv1  initiE 1:/# /= initiE 1:/# /= ifF 1:/# initiE /#. 
+ move : H2;rewrite !tP => H2 i ib.
  move : (H2 i ib);rewrite !initiE 1..3:/# /= addrC => <-.
  rewrite /G_mhpk /SHA3_512_64_64 /= get_of_list /#.
+ by smt().
+ by smt().
by move => ????r0 r1 ??;do split;smt(Array32.initiE).
qed.


lemma verify_correct_h _ctp _ctp1 :
  hoare [Jkem1024_avx2.M.__verify : 
             arg = (_ctp,_ctp1) ==>
             (_ctp = _ctp1 => 
                       res = W64.of_int 0) /\
             (_ctp <> _ctp1 => 
                       res = W64.of_int 1)].
proc => /=.

wp; while (#pre /\ 0 <= i{hr} <= 49 /\ inc{hr} = 49 /\
           (to_uint h{hr} = 0 <=> 
            forall k, 0 <= k < i{hr}*32 => _ctp.[k] = _ctp1.[k])); last first.
+ auto => />; split; 1: by smt().
  move => h i ??? [HL HR]; split; last first.
  + rewrite tP => H1.
    rewrite /VPTEST_256 /= /ZF_of /= ifT //.
    move : H1; rewrite negb_forall /= => [[k H]]. 
    move : H; rewrite negb_imply  /= => [# H1 H2 H3].
    rewrite implybE in HL; elim HL; smt(to_uint0). 

  + rewrite tP => H1.
    rewrite /VPTEST_256 /= /ZF_of /= ifF //.
    rewrite implybE in HR; elim HR.
    +  rewrite negb_forall /= => [[k H]].  
       move : H; rewrite negb_imply  /= => [# H2 H3 H4].
       smt(Array1568.initiE).
    smt(W256.to_uint_eq W256.to_uint0).

auto => /> &hr ?? [HL HR] ?.
pose x := 
      ((WArray1568.get256 ((WArray1568.init8 ("_.[_]" _ctp1))) i{hr})) `^`
      (WArray1568.get256 ((WArray1568.init8 ("_.[_]" _ctp))) i{hr}).
do split; 1..2: by smt().
+ move => H0 k kbl kbh.

  have H1 : to_uint h{hr} = 0. 
  + have : h{hr} = W256.zero; last by rewrite to_uint_eq /=.
    have : (h{hr} `|` x) = W256.zero by rewrite to_uint_eq  H0 /=.
    by rewrite !wordP; smt(orwE zerowE).

  have H2 : x = W256.zero.
  + have : (h{hr} `|` x) = W256.zero by rewrite to_uint_eq  H0 /=. 
    by rewrite !wordP; smt(orwE zerowE).

  case (k < i{hr}*32); 1: by move => *; apply (HL _ _) => // /#. 
 
  move => kv.
  move : H2; rewrite /x W256.WRing.addr_eq0 /oppw /=. 
  rewrite /init8 /loadW256 /loadW8 /get256_direct wordP => H2.
  apply W8.wordP => j jb.
  move : (H2 ((k - i{hr} * 32) * 8 + j) _). smt().
  rewrite !pack32wE /=; 1,2: smt().
  rewrite !initiE /=; 1,2: smt().
  rewrite !initiE /=; 1,2: smt().
  by smt().

move => H0.
have -> : h{hr} = W256.zero by rewrite to_uint_eq /= /#.
rewrite or0w;have -> : x = W256.zero; last by auto.
rewrite wordP => k kb; rewrite zerowE /x.
move : H0;rewrite /init8 /loadW256 /loadW8 /get256_direct => H0. 
pose xx := pack32_t _.
pose yy := pack32_t _.
have -> : xx = yy; last by rewrite xorwK_s //.
rewrite /xx /yy wordP => j jb.
  rewrite !pack32wE /=; 1,2: smt().
  rewrite !initiE /=; 1,2: smt().
  rewrite !initiE /=; 1,2: smt().
  by smt().
qed.

lemma verify_ll : islossless Jkem1024_avx2.M.__verify.
proc.
wp.
while (0 <= i{hr} <= 49 /\ inc{hr} = 49) (49 - i{hr}).
auto => /> /#.
auto => /> /#. 
qed.

lemma verify_correct _ctp _ctp1 :
  phoare  [Jkem1024_avx2.M.__verify : 
             arg = (_ctp,_ctp1) ==>
             (_ctp = _ctp1 => 
                       res = W64.of_int 0) /\
             (_ctp <> _ctp1 => 
                       res = W64.of_int 1)] = 1%r 
   by conseq verify_ll (verify_correct_h _ctp _ctp1).

lemma cmov_correct_h _dst _src   _cnd  :
   hoare [Jkem1024_avx2.M.__cmov : 
          dst = _dst /\   src = _src /\ cnd = _cnd  ==>
             (_cnd = W64.of_int 0 => 
               res = _src) /\
             (_cnd = W64.of_int 1 => 
               res = _dst)].
proc => /=.
seq 1 : (#{/~cnd}pre /\ (_cnd = W64.zero => cnd = W64.zero) /\
                (_cnd = W64.one => cnd = W64.onew));
  1: by auto => />   /=; split; [ by ring | by rewrite W64.minus_one /=].


auto => /> &hr H H0.

have msb1 : forall i,  0 <= i < 8 => msb (W64.onew \bits8 i) = true.
+ move => i ib; rewrite /msb /=.
  have -> : W64.onew \bits8 i = W8.onew.
  + rewrite wordP => k kb.
    rewrite onewE /= kb /= bits8iE //= /#.
  by rewrite  to_uint_onew /=.

have msb0 : forall i, 0 <= i <8 => msb (W64.zero \bits8 i) = false.
+ move => i ib; rewrite /msb /=.
  have -> : W64.zero \bits8 i = W8.zero.
  + rewrite wordP => k kb.
    rewrite zerowE  /= bits8iE //= /#.
  by rewrite to_uint0 /=.

do split.
+ rewrite tP => H1 k  kb;rewrite (H H1).
  rewrite initiE 1:/# /= kb /=.
rewrite /get256_direct /init8 /loadW256 /loadW8 /= wordP => i ib.
rewrite   /VPBROADCAST_4u64 /(\bits8) -iotaredE /= /VPBLENDVB_256 /VPBLENDVB_128  /=  initiE 1:/# /=.
by rewrite !msb0 1..8:/# pack32E initiE /= 1:/# /of_list initiE /= /#.
 
+ move =>cone; move : (H0 cone) => -> /=;rewrite tP => k kb.
rewrite initiE 1:/# /= kb /=.
rewrite /get256_direct /init8 /loadW256 /loadW8 /= wordP => i ib.
rewrite   /VPBROADCAST_4u64 /(\bits8) -iotaredE /= /VPBLENDVB_256 /VPBLENDVB_128  /=   !msb1 //=  initiE //=.
by rewrite pack32E initiE /= 1:/# /of_list !initiE /= /#.
qed.

lemma cmov_ll : islossless Jkem1024_avx2.M.__cmov by islossless.


lemma cmov_correct _dst _src _cnd:
   phoare [Jkem1024_avx2.M.__cmov : 
        dst=_dst /\   src = _src /\ cnd = _cnd  ==>
             (_cnd = W64.of_int 0 => 
               res = _src) /\
             (_cnd = W64.of_int 1 => 
               res = _dst)] = 1%r
  by  conseq cmov_ll (cmov_correct_h _dst _src _cnd). 

lemma mlkem_kem_correct_dec : 
   equiv [Jkem1024_avx2.M.jade_kem_mlkem_mlkem1024_amd64_avx2_dec ~ MLKEM1024.dec: 
      sk{2}.`1 = Array1536.init(fun i => secret_key{1}.[i])  /\
      sk{2}.`2.`1 = Array1536.init(fun i => secret_key{1}.[i+1536]) /\
      sk{2}.`2.`2 = Array32.init(fun i => secret_key{1}.[i+1536+1536]) /\
      sk{2}.`3 = Array32.init(fun i => secret_key{1}.[i+1536+1536 + 32]) /\
      sk{2}.`4 = Array32.init(fun i => secret_key{1}.[i+1536+1536 + 32 + 32]) /\
     let (c1,c2) = cph{2} in
         cph{2}.`1 = Array1408.init(fun i => ciphertext{1}.[i]) /\
         cph{2}.`2 = Array160.init(fun i => ciphertext{1}.[i+1408])  
       ==> 
     res{2} = res{1}.`1
].
proc. 
proc rewrite {1} 8 (copy1568).
proc rewrite {1} 9 (copy3168).
proc rewrite {1} 17 (copy32).
inline {1} 13.
proc rewrite {1} 25 (copy3168).

swap {1} [16..22] -15.
seq 13 0 : #pre; 1: by auto.
sp;seq 1 1 : (#pre /\ aux{1} = m{2}); 
  1: by call (mlkem_correct_dec_avx2); 1: by auto => /> /#.

seq 5 1 : (#pre /\ 
           (forall k, 0<=k<32 => buf{1}.[k] = m{2}.[k]) /\
           (forall k, 0<=k<32 => kr{1}.[k] = _K{2}.[k]) /\
           (forall k, 0<=k<32 => kr{1}.[k+32] = r{2}.[k])).
+ ecall {1} (sha3_512A_512A_A64 m{2} hpk{2}).
  wp; conseq (_: _ ==> 
   (forall k, 0<=k<32 => buf{1}.[k] = m{2}.[k]) /\
   (forall k, 32<=k<64 => buf{1}.[k] = s_sk{1}.[3104 + k - 32]) /\
   (forall k, 0<=k<32 => buf{1}.[k] = aux{1}.[k])).
+ auto => /> &1 &2; rewrite  !tP => ???buf bvl bvh ; split.
  + split; rewrite tP => *; rewrite initiE /= 1:/#;1: by smt().
    by rewrite initiE /#.
  move => H H0 H1 H2 H3; do split.
  + move => k kbl kbh. 
    move : H2;rewrite tP => H2.
    move : (H2 k _);1:smt().
    rewrite  initiE 1:/# /= initiE 1:/# /= => <-.
    by rewrite /G_mhpk /SHA3_512_64_64 /= initiE 1:/# /=.
  + move => k kbl kbh. 
    move : H3;rewrite tP => H3.
    move : (H3 k _);1:smt().
    rewrite  initiE 1:/# /= initiE 1:/# /= => <-.
    by rewrite /G_mhpk /SHA3_512_64_64 /= initiE 1:/# /=.

  while {1} (0<=i{1}<=4 /\ inc{1} = 4  /\ 
             (forall (k : int), 32 <= k && k < 32 + 8*i{1} => buf{1}.[k] = s_sk{1}.[3104 + k - 32]) /\
             forall (k : int), 0 <= k && k < 32 => buf{1}.[k] = aux{1}.[k]) (4 - i{1}); last first. 
  + auto => /> &1 &2 ??? /=;do split.
    + by move => *;rewrite initiE 1:/# /= ifT 1:/#;smt(Array32.initiE).
    + by move => *;rewrite initiE 1:/# /= ifT 1:/#;smt(Array1536.initiE).
    + by smt().
  move => *; auto => /> &hr ?????; do split; 1..2,5: by smt().
  +  move => k kbl kbh; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((i{hr} + 4) * 8 <= k && k < (i{hr} + 4) * 8 + 8 ) => *.
      + by rewrite WArray3168.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array1536.initiE).
  +  move => k kbl kbh; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((i{hr} + 4) * 8 <= k && k < (i{hr} + 4) * 8 + 8) => *.
      + by rewrite WArray3168.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array1536.initiE).
  
swap {2} 1 1.  
seq 1 1 : (#pre /\ 
           ctc{1} = Array1568.init (fun i => if i < 1408 then c{2}.`1.[i] else c{2}.`2.[i-1408])).
+ call (mlkem_correct_enc_avx2).

  auto => /> &1 &2 ?; rewrite !tP => ?????; do split.
  + by smt(Array32.initiE).
  + by smt(Array32.initiE).
  + move => *;rewrite initiE 1:/# /= initiE 1:/# /=.
    by smt(Array1536.initiE).
  + move => *;rewrite initiE 1:/# /= initiE 1:/# /=.
    by smt(Array32.initiE).

  move => /= ? ? bufv ? krv rl rr H. 
  rewrite tP => i ib.
  rewrite !initiE //=. 
  by  smt(Array160.initiE Array1408.initiE).

seq 1 0 : #pre; 1: by auto. 
seq 1 0 : (#pre /\ 
                  (c{2}  = cph{2} => cnd{1} = W64.of_int 0) /\
                  (c{2}  <> cph{2} => cnd{1} = W64.of_int 1)).
+  conseq (_: _ ==> (c{2}  = cph{2} => cnd{1} = W64.of_int 0) /\
                  (c{2}  <> cph{2} => cnd{1} = W64.of_int 1)); 1: smt(). 
   ecall {1} (verify_correct ct0{1} ctc{1}).
   auto => /> &1 &2; rewrite  /= !tP.
   move  => ??cphv???rst Heq Hdiff.
   rewrite (_: cph{2} = (cph{2}.`1, cph{2}.`2)) /= in cphv; 1: by smt().
   move : cphv; move => [cphv1 cphv2].
   split.
   + move => ceq; rewrite (Heq _); last by done.
     move => i0 ib; rewrite !initiE //=. 
     case (i0 < 1408).
     + by move => ibb; rewrite ceq cphv1 1: /# initiE /= /#.
     by move => ibb; rewrite ceq cphv2 1: /# initiE /= /#. 
   move => neq;rewrite Hdiff. 
   have : exists i0, 0<= i0 < 1568 /\ 
     (ciphertext{1}.[i0]  <>
     (Array1568.init (fun (i1 : int) => if i1 < 1408 then c{2}.`1.[i1] else c{2}.`2.[i1 - 1408])).[i0]); last by smt().
   case (c{2}.`1 <> cph{2}.`1).
   + move => neq1. rewrite tP in neq1.   
     have [k kb] : exists k, 0<=k<1408 /\ c{2}.`1.[k] <> cph{2}.`1.[k] by smt().
     exists k; split; 1: by smt().
     rewrite !initiE /= 1:/# /=. 
     move : (cphv1 k _); 1: smt().
     by rewrite initiE /= /#.
   + move => eq1. 
     have neq2 : c{2}.`2 <> cph{2}.`2 by move : neq eq1; smt().
     rewrite tP in neq2.   
     have [k kb] : exists k, 0<=k<160 /\ c{2}.`2.[k] <> cph{2}.`2.[k] by smt().
     exists (k + 1408); split; 1: by smt().
     rewrite !initiE /= 1:/# /=. 
     move : (cphv2 k _); 1: smt().
     by rewrite initiE /= /#.
  done.


wp;ecall {1} (cmov_correct shk0{1} (Array32.init (fun (i_0 : int) => kr{1}.[0 + i_0])) cnd{1}).

wp;ecall{1} (shake256_A32_A1600_ph zp_ct{1}).
conseq />;1: smt().

sp 2 0.
seq 3 0 : (#pre /\
      z{2} = Array32.init (fun i => zp_ct{1}.[i]) 
).

+ wp;while {1} (#pre /\ 
    inc{1} = 4 /\ 0<=i{1} <= inc{1} /\
    (forall k, 0<= k < 8 * i{1}  => 
         z{2}.[k] = zp_ct{1}.[k]))
    (4 - i{1}).
  move => &m z;auto => /> &hr.
  move => ???????????prev2.
  do split;1,2:smt().
  +  move => i ibl ibh; rewrite initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  (8 * i{!hr} <= i && i < 8 * i{!hr} + 8) => *.
      + by rewrite WArray3168.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array32.initiE).
  + by smt().

  auto => /> &1 &2; rewrite !tP.
  move =>  *.
  do split; 1: by smt(). 
  move => il zpct.
  rewrite !tP; split; 1: smt().
  by move => *; rewrite initiE 1:/# /= initiE 1:/# /=;smt(Array32.initiE).

+ wp;while {1} (#pre /\ 
    inc{1} = (4 * 352 + 160) %/ 8 /\ 0<=i{1} <= inc{1} /\
    (forall k, 0<= k < min (8 * i{1}) 1408  => 
         cph{2}.`1.[k] = zp_ct{1}.[32+k]) /\
    (forall k, 1408 <= k < min (8 * i{1}) (1408 + 160) => 
         cph{2}.`2.[k-1408] = zp_ct{1}.[32+k]))
    ((4 * 384 + 32) %/ 8 - i{1}).
  move => &m z;auto => /> &hr.
 
  auto => />; rewrite !tP.
  move => pkv1 pkv2 c?????prev0?? prev1 prev2?.
  do split.
  +  move => k kb; rewrite initiE 1:/# /= initiE 1:/# /= initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case  ((i{hr} + 4) * 8 <= k && k < (i{hr} + 4) * 8 + 8) => *.
      + by rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /= initiE /#.
      by rewrite /get8 initiE; smt(Array32.initiE).
  + by smt().
  + by smt().
  +  move => k kb kbb; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ((i{hr} + 4) * 8 <= 32 + k && 32 + k < (i{hr} + 4) * 8 + 8) => *.
      + rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /=.
      rewrite /get8 initiE /= 1:/#; move : c;  smt(Array1408.initiE).
    + by rewrite /get8 initiE /= 1:/#; move : c;   smt(Array1120.initiE).
  +  move => k kb kbb; rewrite initiE 1:/# /=.
      rewrite get8_set64_directE 1,2:/# /=.
      case ((i{hr} + 4) * 8 <= 32 + k && 32 + k < (i{hr} + 4) * 8 + 8) => *.
      + rewrite WArray1568.get64E pack8bE 1:/# initiE 1:/# /=.
      by rewrite /get8 initiE 1:/#;  smt(Array160.initiE).
    + rewrite /get8 initiE 1:/# /=;  smt(Array1408.initiE).
  + by smt().

  auto => /> &1 &2; rewrite !tP.
  move =>  ?????????.
  do split; 1..2: by smt(). 
  move => il zpct.
  rewrite !tP; split; 1: smt().
  move => ?????? rr Hrr0 Hrr1; do split. 
  + move => *; rewrite tP => kk kkb;rewrite initiE 1:/# /=.
    rewrite Hrr1 1:/# /= /SHAKE_256_1120_32 /= get_of_list 1:/# /=.
    congr;congr;congr;congr.
    + congr;rewrite tP => jj jjb;smt(Array32.initiE).
    + congr;rewrite tP => jj jjb;smt(Array1408.initiE).
    + rewrite tP => jj jjb;smt(Array160.initiE).
    move => Hok;rewrite Hrr0 1:/#  tP => jj jjb;smt(Array32.initiE).

qed.
