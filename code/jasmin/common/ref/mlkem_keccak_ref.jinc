from Keccak require "ref/select_bmi1.jinc"
from Keccak require "common/keccak1600_generic.jinc"

from Keccak require "ref/keccak1600.jinc"

namespace A32 {
  param int _ASIZE = 32;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A33 {
  param int _ASIZE = 33;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A34 {
  param int _ASIZE = 34;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A64 {
  param int _ASIZE = 64;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A128 {
  param int _ASIZE = 128;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A168 {
  param int _ASIZE = 168;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1088 {
  param int _ASIZE = 1088;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1184 {
  param int _ASIZE = 1184;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1568 {
  param int _ASIZE = 1568;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

fn _shake256_128_33
( reg mut ptr u8[128] out
, reg const ptr u8[33] in
) -> reg ptr u8[128]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  st = st_s;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A33::__absorb_ref(st, 0, in, SHAKE, R136);
  () = #unspill(out);
  _, out = A128::__squeeze_ref(st, out, R136);

  return out;
}

fn _shake256_A32__A1120
( reg mut ptr u8[32] out
, reg const ptr u8[32] in0
, reg const ptr u8[1088] in1) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  st = st_s;
  st = __state_init_ref(st);
  () = #spill(out, in1);
  st, _ = A32::__absorb_ref(st, 0, in0, UNFINISHED, R136);
  () = #unspill(in1);
  st, _ = A1088::__absorb_ref(st, 32, in1, SHAKE, R136);
  () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);
  return out;
}

fn _shake256_A32__A1600
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in0
, reg const ptr u8[1568] in1) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  () = #spill(out);
  () = #spill(in1);
  st = st_s;
  st = __state_init_ref(st);
  st, _ = A32::__absorb_ref(st, 0, in0, UNFINISHED, R136);
  () = #unspill(in1);
  st, _ = A1568::__absorb_ref(st, 32, in1, SHAKE, R136);
  () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);
  return out;
}

fn _sha3_512A_A33
( reg mut ptr u8[64] out,
  reg const ptr u8[33] in
) -> reg ptr u8[64]
{ 
  stack u64[25] st_s;
  reg ptr u64[25] st;
  st = st_s;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A33::__absorb_ref(st, 0, in, SHA3, R72);
  () = #unspill(out);
  _, out = A64::__squeeze_ref(st, out, R72);
  return out;
}

fn _shake128_absorb34
( reg mut ptr u64[25] st
, reg const ptr u8[34] in
) -> reg ptr u64[25]
{ 
  st = __state_init_ref(st);
  st, _ = A34::__absorb_ref(st, 0, in, SHAKE, R168);
  return st;
}

fn _shake128_squeezeblock
( reg mut ptr u64[25] st
, reg mut ptr u8[R168] out
) -> reg ptr u64[25], reg ptr u8[R168]
{ 
  () = #spill(out);
  st = _keccakf1600_ref(st);
  () = #unspill(out);
  out, _ = A168::__dumpstate_ref(out, 0, R168, st); 
 return st, out;
}

fn _sha3_256A_A1184
( reg mut ptr u8[32] out
, reg ptr u8[1184] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  st, _ = A1184::__absorb_ref(st, 0, in, SHA3, R136);
  () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);

  return out;
}

fn _sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, reg ptr u8[1568] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  st, _ = A1568::__absorb_ref(st, 0, in, SHA3, R136);
  () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);

  return out;
}

fn _isha3_256_32
( reg mut ptr u8[32] out
, reg ptr u8[32] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  
  st = st_s;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A32::__absorb_ref(st, 0, in, SHA3, R136);
  () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);

  return out;
}

fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

  st = st_s;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A64::__absorb_ref(st, 0, in, SHA3, R72);
  () = #unspill(out);
  _, out = A64::__squeeze_ref(st, out, R72);

  return out;
}



//
//
// FOR TESTING!!!
//
//

namespace A1 {
  param int _ASIZE = 1;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A2 {
  param int _ASIZE = 2;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1120 {
  param int _ASIZE = 1120;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1600 {
  param int _ASIZE = 1600;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace ABUFLEN {
  param int _ASIZE = 536;
  from Keccak require "ref/keccak1600_fixedsizes_ASIZE.jinc"
}



export fn sha3_512A_A33
( reg mut ptr u8[64] out
, reg const ptr u8[33] in
) -> reg ptr u8[64]
{ stack u64[25] st;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A33::__absorb_ref(st, 0, in, SHA3, R72);
  () = #unspill(out);
  _, out = A64::__squeeze_ref(st, out, R72);
  return out;
}

export fn sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ stack u64[25] st;
  st = __state_init_ref(st);
  () = #spill(out);
  st, _ = A64::__absorb_ref(st, 0, in, SHA3, R72);
  () = #unspill(out);
  _, out = A64::__squeeze_ref(st, out, R72);
  return out;
}

export fn shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ stack u64[25] st;
  st = __state_init_ref(st);
  () = #spill(out, nonce);
  st, _ = A32::__absorb_ref(st, 0, seed, UNFINISHED, R136);
  () = #unspill(nonce);
  st, _ = A1::__absorb_ref(st, 32, nonce, SHAKE, R136);
  () = #unspill(out);
  _, out = A128::__squeeze_ref(st, out, R136);

  return out;
}

export fn shake128_absorb_squeeze3blocks
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
, reg const ptr u8[32] seed
, reg const ptr u8[2] pos
) -> reg ptr u8[ABUFLEN::_ASIZE]
{
 stack u64[25] st;
 reg ui64 offset;

 st = __state_init_ref(st);
 () = #spill(buf,pos);
 st, _ = A32::__absorb_ref(st, 0, seed, UNFINISHED, R168);
 () = #unspill(pos);
 st, _ = A2::__absorb_ref(st, 32, pos, SHAKE, R168);

 st = _keccakf1600_ref(st);
 offset = 0;
 () = #unspill(buf);
 buf, offset = ABUFLEN::__dumpstate_ref(buf, offset, R168, st);
 () = #spill(buf,offset);
 st = _keccakf1600_ref(st);
 () = #unspill(buf,offset);
 buf, offset = ABUFLEN::__dumpstate_ref(buf, offset, R168, st);
 () = #spill(buf,offset);
 st = _keccakf1600_ref(st);
 () = #unspill(buf,offset);
 buf, offset = ABUFLEN::__dumpstate_ref(buf, offset, 200, st);
 return buf;
}

export fn shake128_next_state
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
) -> reg ptr u8[ABUFLEN::_ASIZE] /* buf */
{
 reg ptr u64[25] pst;

 pst = buf[:u64 2*(168/8) : 25];
 () = #spill(buf);
 pst = _keccakf1600_ref(pst);
 () = #unspill(buf);
 buf[:u64 2*(168/8) : 25] = pst;

 return buf;
}

export fn sha3_256A_A1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1184] in
) -> reg ptr u8[32]
{ stack u64[25] st;
  st = __state_init_ref(st);
 () = #spill(out);
  st, _ = A1184::__absorb_ref(st, 0, in, SHA3, R136);
 () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);

  return out;
}

export fn sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1568] in
) -> reg ptr u8[32]
{ stack u64[25] st;
  st = __state_init_ref(st);
 () = #spill(out);
  st, _ = A1568::__absorb_ref(st, 0, in, SHA3, R136);
 () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);

  return out;
}

export fn shake256_A32__A1120
(  reg mut ptr u8[32] out
,  reg const ptr u8[1120] in
) -> reg ptr u8[32]
{ stack u64[25] st;
  st = __state_init_ref(st);
 () = #spill(out);
  st, _ = A1120::__absorb_ref(st, 0, in, SHAKE, R136);
 () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);
  return out;
}

export fn shake256_A32__A1600
(  reg mut ptr u8[32] out
,  reg const ptr u8[1600] in
) -> reg ptr u8[32]
{ stack u64[25] st;
  st = __state_init_ref(st);
 () = #spill(out);
  st, _ = A1600::__absorb_ref(st, 0, in, SHAKE, R136);
 () = #unspill(out);
  _, out = A32::__squeeze_ref(st, out, R136);
  return out;
}

