from Keccak require "ref/keccak1600_imem_ref.jinc"

namespace A32 {
  param int ASIZE = 32;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A33 {
  param int ASIZE = 33;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A34 {
  param int ASIZE = 34;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A64 {
  param int ASIZE = 64;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A128 {
  param int ASIZE = 128;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A168 {
  param int ASIZE = 168;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A1088 {
  param int ASIZE = 1088;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A1184 {
  param int ASIZE = 1184;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

namespace A1568 {
  param int ASIZE = 1568;
  from Keccak require "ref/keccak1600_array_ref_ASIZE.jinc"
}

fn _shake256_128_33
( #spill_to_mmx reg mut ptr u8[128] out
, reg const ptr u8[33] in
) -> reg ptr u8[128]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A33::__absorb_array_ref(st, 0, in, offset, 33, R136, SHAKE);
  offset = 0;
  () = #unspill(out);
  out, _, _ = A128::__squeeze_array_ref(out, offset, 128, st, R136);

  return out;
}

fn _shake256_A32__A1120
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in0
, reg const ptr u8[1088] in1) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A32::__absorb_array_ref(st, 0, in0, offset, 32, R136, UNFINISHED);
  offset = 0;
  st, _, _ = A1088::__absorb_array_ref(st, 32, in1, offset, 1088, R136, SHAKE);
  offset = 0;
  out,_, _ = A32::__squeeze_array_ref(out, offset,32, st, R136);
  return out;
}

fn _shake256_A32__A1600
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in0
, reg const ptr u8[1568] in1) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A32::__absorb_array_ref(st, 0, in0, offset, 32, R136, UNFINISHED);
  offset = 0;
  st, _, _ = A1568::__absorb_array_ref(st, 32, in1, offset, 1568, R136, SHAKE);
  offset = 0;
  out,_, _ = A32::__squeeze_array_ref(out, offset,32, st, R136);
  return out;
}

fn _shake256_1600_32
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in0
, reg const ptr u8[1568] in1) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A32::__absorb_array_ref(st, 0, in0, offset, 32, R136, UNFINISHED);
  offset = 0;
  st, _, _ = A1568::__absorb_array_ref(st, 32, in1, offset, 1568, R136, SHAKE);
  offset = 0;
  out,_, _ = A32::__squeeze_array_ref(out, offset,32, st, R136);
  return out;
}



/* SHA3-512 writing to a 64-byte stack array (512A) and reading from 33 byte
   stack array */
fn _sha3_512A_A33
( reg mut ptr u8[64] out,
  reg const ptr u8[33] in
) -> reg ptr u8[64]
{ 
  stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;
  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A33::__absorb_array_ref(st, 0, in, offset, 33, R72, SHA3);
  offset = 0;
  out, _, _ = A64::__squeeze_array_ref(out, offset, 64, st, R72);
  return out;
}

fn _shake128_absorb34
( reg mut ptr u64[25] st
, reg const ptr u8[34] in
) -> reg ptr u64[25]
{ reg u64 offset;

  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A34::__absorb_array_ref(st, 0, in, offset, 34, R168, SHAKE);

  return st;
}

fn _shake128_squeezeblock
( reg mut ptr u64[25] st
, #spill_to_mmx reg mut ptr u8[R168] out
) -> reg ptr u64[25], reg ptr u8[R168]
{ reg u64 offset;

  () = #spill(out);
  st = _keccakf1600_ref(st);
  () = #unspill(out);
  offset = 0;
  out, _ = A168::__dumpstate_array_ref(out, offset, R168, st);

  return st, out;
}

#[returnaddress="stack"]
fn _sha3_256A_A1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg ptr u8[1184] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  st, _, _ = A1184::__absorb_array_ref(st, 0, in, 0, 1184, R136, SHA3);
  offset = 0;
  () = #unspill(out);
  out, _, _ = A32::__squeeze_array_ref(out, offset, 32, st, R136);

  return out;
}

#[returnaddress="stack"]
fn _sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg ptr u8[1568] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  st, _, _ = A1568::__absorb_array_ref(st, 0, in, 0, 1568, R136, SHA3);
  offset = 0;
  () = #unspill(out);
  out, _, _ = A32::__squeeze_array_ref(out, offset, 32, st, R136);

  return out;
}

#[returnaddress="stack"]
fn _isha3_256_32
( #spill_to_mmx reg mut ptr u8[32] out
, reg ptr u8[32] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A32::__absorb_array_ref(st, 0, in, offset, 32, R136, SHA3);
  offset = 0;
  () = #unspill(out);
  out, _, _ = A32::__squeeze_array_ref(out, offset, 32, st, R136);

  return out;
}

#[returnaddress="stack"]
fn _sha3_512A_A64
( #spill_to_mmx reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
  reg u64 offset;

  () = #spill(out);
  st = st_s;
  st = __state_init_ref(st);
  offset = 0;
  st, _, _ = A64::__absorb_array_ref(st, 0, in, offset, 64, R72, SHA3);
  offset = 0;
  () = #unspill(out);
  out, _, _ = A64::__squeeze_array_ref(out, offset, 64, st, R72);

  return out;
}
