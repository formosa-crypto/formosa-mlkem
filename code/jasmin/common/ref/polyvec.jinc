require "poly.jinc"

inline
fn __polyvec_add2(stack u16[MLKEM_VECN] r, stack u16[MLKEM_VECN] b) -> stack u16[MLKEM_VECN]
{
  inline int i;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = _poly_add2(r[MLKEM_N*i:MLKEM_N], b[MLKEM_N*i:MLKEM_N]);
  }
  return r;
}

inline
fn __polyvec_csubq(stack u16[MLKEM_VECN] r) -> stack u16[MLKEM_VECN]
{
  inline int i;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = _poly_csubq(r[MLKEM_N*i:MLKEM_N]);
  }
  return r;
}

inline
fn __polyvec_frombytes(reg u64 ap) -> stack u16[MLKEM_VECN]
{
  stack u16[MLKEM_VECN] r;
  reg u64 pp;
  inline int i;

  pp = ap;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = _poly_frombytes(r[MLKEM_N*i:MLKEM_N], pp);
    pp += MLKEM_POLYBYTES;
  }
  return r;
}

inline
fn __polyvec_invntt(stack u16[MLKEM_VECN] r) -> stack u16[MLKEM_VECN]
{
  inline int i;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = _poly_invntt(r[MLKEM_N*i:MLKEM_N]);
  }
  return r;
}

inline
fn __polyvec_ntt(stack u16[MLKEM_VECN] r) -> stack u16[MLKEM_VECN]
{
  inline int i;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = _poly_ntt(r[MLKEM_N*i:MLKEM_N]);
  }
  return r;
}

inline
fn __polyvec_pointwise_acc(stack u16[MLKEM_VECN] a, stack u16[MLKEM_VECN] b) -> stack u16[MLKEM_N]
{
  stack u16[MLKEM_N] t;
  stack u16[MLKEM_N] r;
  inline int i;

  r = _poly_basemul(r, a[0:MLKEM_N], b[0:MLKEM_N]);
  for i = 1 to MLKEM_K
  {
    t = _poly_basemul(t, a[MLKEM_N*i:MLKEM_N], b[MLKEM_N*i:MLKEM_N]);
    r = _poly_add2(r, t);
  }
  r = __poly_reduce(r);

  return r;
}

inline
fn __polyvec_reduce(stack u16[MLKEM_VECN] r) -> stack u16[MLKEM_VECN]
{
  inline int i;
  for i = 0 to MLKEM_K
  {
    r[MLKEM_N*i:MLKEM_N] = __poly_reduce(r[MLKEM_N*i:MLKEM_N]);
  }
  return r;
}

inline
fn __polyvec_tobytes(reg u64 rp, stack u16[MLKEM_VECN] a)
{
  reg u64 pp;
  inline int i;

  pp = rp;
  for i = 0 to MLKEM_K
  {
    a[MLKEM_N*i:MLKEM_N] = _poly_tobytes(pp, a[MLKEM_N*i:MLKEM_N]);
    pp += MLKEM_POLYBYTES;
  }
}
