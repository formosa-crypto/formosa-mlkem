from Keccak require "avx2/keccak1600_fixedsizes.jinc"
from Keccak require "avx2/keccak1600x4_fixedsizes.jinc"

/* instantiate the Keccak code with variants for reading/writing
   from/to stack arrays with different sizes */
namespace A1 {
  param int _ASIZE = 1;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A2 {
  param int _ASIZE = 2;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A32 {
  param int _ASIZE = 32;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A33 {
  param int _ASIZE = 33;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A64 {
  param int _ASIZE = 64;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A128 {
  param int _ASIZE = 128;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A1184 {
  param int _ASIZE = 1184;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A1568 {
  param int _ASIZE = 1568;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A1120 {
  param int _ASIZE = 1120;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace A1600 {
  param int _ASIZE = 1600;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}

namespace ABUFLEN {
  param int _ASIZE = 536;
  from Keccak require "avx2/keccak1600_fixedsizes_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"
}


namespace NEW {

/* SHA3-512 writing to a 64-byte stack array (512A) and reading from 33 byte
   stack array */
fn _sha3_512A_A33
( #spill_to_mmx reg mut ptr u8[64] out
, reg const ptr u8[33] in
) -> reg ptr u8[64]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A33::__absorb_avx2(st, 0, in, SHA3, R72);
  _, out = A64::__squeeze_avx2(st, out, R72);
  return out;
}

/* SHA3-512 writing to a 64-byte stack array (512A) and reading from 64 byte
   stack array */
fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A64::__absorb_avx2(st, 0, in, SHA3, R72);
  _, out = A64::__squeeze_avx2(st, out, R72);
  return out;
}

/* SHAKE-256 writing to a 128-byte stack array (A128) and reading from 32 byte
   stack array first, and then from a 1 byte stack array next */
fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A32::__absorb_avx2(st, 0, seed, UNFINISHED, R136);
  st, _ = A1::__absorb_avx2(st, 32, nonce, SHAKE, R136);
  _, out = A128::__squeeze_avx2(st, out, R136);

  return out;
}

/* 4-way parallel SHAKE-256 writing to 128-byte stack arrays (A128) and reading from 32 byte
   stack array first (same input on all lanes), and then from 1 byte stack arrays next */
fn _shake256x4_A128__A32_A1
( reg mut ptr u8[128] out0 out1 out2 out3
, reg const ptr u8[32] seed
, reg const ptr u8[4] nonces
) -> reg ptr u8[128] /* out0 */
   , reg ptr u8[128] /* out1 */
   , reg ptr u8[128] /* out2 */
   , reg ptr u8[128] /* out3 */
{ stack u256[25] st_s;
  reg ptr u256[25] st;
  st = st_s;
  st = __state_init_avx2x4(st);
  st, _ = A32::__absorb_bcast_avx2x4(st, 0, seed, UNFINISHED, R136);
  st, _ = A1::__absorb_avx2x4(st, 32, nonces[0:1], nonces[1:1], nonces[2:1], nonces[3:1], SHAKE, R136);
  st, out0, out1, out2, out3
    = A128::__squeeze_avx2x4(st, out0, out1, out2, out3, R136);

  return out0, out1, out2, out3;
}

/* SHAKE-128 absorb reading from a 32-byte stack array (A32) first and from 2 byte
   stack array next */
fn _shake128_absorb_A32_A2
( reg const ptr u8[32] seed
, reg const ptr u8[2] pos
) -> reg u256[7]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A32::__absorb_avx2(st, 0, seed, UNFINISHED, R168);
  st, _ = A2::__absorb_avx2(st, 32, pos, SHAKE, R168);

  return st;
}

/* 4-way SHAKE-128 absorb reading from a 32-byte stack array (A32) first (same on all
   lanes) and from 2 byte stack arrays next */
fn _shake128x4_absorb_A32_A2
( reg mut ptr u256[25] st
, reg const ptr u8[32] seed
, reg const ptr u8[4*2] pos
) -> reg ptr u256[25]
{ inline int AT;
  st = __state_init_avx2x4(st);
  st, AT = A32::__absorb_bcast_avx2x4(st, 0, seed, UNFINISHED, R168);
  st, _ = A2::__absorb_avx2x4(st, 32, pos[0:2], pos[2:2], pos[4:2], pos[6:2], SHAKE, R168);

  return st;
}

/* SHAKE-128 squeeze the next 504 bytes and keep the full state
   at the end so it can be resumed */
fn _shake128_squeeze3blocks
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
, reg u256[7] st
) -> reg ptr u8[ABUFLEN::_ASIZE]
{
 reg ui64 offset;
 st = _keccakf1600_avx2(st);
 offset = 0;
 buf, offset = ABUFLEN::__dumpstate_avx2(buf, offset, R168, st);
 st = _keccakf1600_avx2(st);
 buf, offset = ABUFLEN::__dumpstate_avx2(buf, offset, R168, st);
 st = _keccakf1600_avx2(st);
 buf, offset = ABUFLEN::__dumpstate_avx2(buf, offset, 200, st);
 return buf;
}

/* SHAKE-128 squeeze the next 168 bytes and keep the full state
   at the end so it can be resumed */
fn _shake128_next_state
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
) -> reg ptr u8[ABUFLEN::_ASIZE] /* buf */
{
 reg ptr u64[25] pst;
/*
 reg u256[7] st;
 reg ui64 offset;
 pst = buf[:u64 2*(168/8) : 25];
 st = __stavx2_pack(pst);
 st = _keccakf1600_avx2(st);
 offset = 2*168;
 buf, _ = ABUFLEN::__dumpstate_avx2(buf, offset, 200, st);
*/
 pst = buf[:u64 2*(168/8) : 25];
 pst = _keccakf1600_st25_avx2(pst);
 buf[:u64 2*(168/8) : 25] = pst;

 return buf;
}

/* 4-way parallel SHAKE-128 squeeze the next 504 bytes and keep the full states
   at the end so they can be resumed */
fn _shake128x4_squeeze3blocks
( reg mut ptr u256[25] st
, reg mut ptr u8[4*ABUFLEN::_ASIZE] buf
) -> reg ptr u256[25]
   , reg ptr u8[4*ABUFLEN::_ASIZE] /* buf */
{
 reg ptr u8[ABUFLEN::_ASIZE] buf0 buf1 buf2 buf3;
 reg ui64 offset;
 buf0 = buf[0*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf1 = buf[1*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf2 = buf[2*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf3 = buf[3*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 offset = 0;
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_avx2x4(buf0, buf1, buf2, buf3, offset, R168, st);
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_avx2x4(buf0, buf1, buf2, buf3, offset, R168, st);
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_avx2x4(buf0, buf1, buf2, buf3, offset, 200, st);
 buf[0*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf0;
 buf[1*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf1;
 buf[2*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf2;
 buf[3*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf3;

 return st, buf;
}

fn _sha3_256A_A1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1184] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A1184::__absorb_avx2(st, 0, in, SHA3, R136);
  _, out = A32::__squeeze_avx2(st, out, R136);

  return out;
}

fn _sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1568] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A1568::__absorb_avx2(st, 0, in, SHA3, R136);
  _, out = A32::__squeeze_avx2(st, out, R136);

  return out;
}

fn _shake256_A32__A1120
(  reg mut ptr u8[32] out
,  reg const ptr u8[1120] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A1120::__absorb_avx2(st, 0, in, SHAKE, R136);
  _, out = A32::__squeeze_avx2(st, out, R136);
  return out;
}

fn _shake256_A32__A1600
(  reg mut ptr u8[32] out
,  reg const ptr u8[1600] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  st = __state_init_avx2();
  st, _ = A1600::__absorb_avx2(st, 0, in, SHAKE, R136);
  _, out = A32::__squeeze_avx2(st, out, R136);
  return out;
}

} // namespace NEW

namespace OLD {

fn _sha3_512A_A33
( #spill_to_mmx reg mut ptr u8[64] out
, reg const ptr u8[33] in
) -> reg ptr u8[64]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  offset = 0;
  st, _ = A33::__absorb_array_avx2(st, in, offset, 33, R72, SHA3);
  offset = 0;
  out, _ = A64::__squeeze_array_avx2(out, offset, 64, st, R72);
  return out;
}

fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  offset = 0;
  st, _ = A64::__absorb_array_avx2(st, in, offset, 64, R72, SHA3);
  offset = 0;
  out, _ = A64::__squeeze_array_avx2(out, offset, 64, st, R72);
  return out;
}

fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ reg u256[7] st;
  stack u64[25] pst_s;
  reg ptr u64[25] pst;
  reg u64 offset;
  pst = pst_s;
  pst, st = __pstate_init_avx2(pst);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 0, st, seed, offset, 32, R136, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A1::__pabsorb_array_avx2(pst, 32, st, nonce, offset, 1, R136, SHAKE);
  offset = 0;
  out, _ = A128::__squeeze_array_avx2(out, offset, 128, st, R136);

  return out;
}

fn _shake256x4_A128__A32_A1
( reg mut ptr u8[128] out0 out1 out2 out3
, reg const ptr u8[32] seed
, reg const ptr u8[4] nonces
) -> reg ptr u8[128] /* out0 */
   , reg ptr u8[128] /* out1 */
   , reg ptr u8[128] /* out2 */
   , reg ptr u8[128] /* out3 */
{ stack u256[25] st_s;
  reg ptr u256[25] st;
  reg u64 offset;
  st = st_s;
  st = __state_init_avx2x4(st);
  offset = 0;
  st, _, _ = A32::__absorb_bcast_array_avx2x4(st, 0, seed, offset, 32, R136, UNFINISHED);
  offset = 0;
  st, _, _ = A1::__absorb_array_avx2x4(st, 32, nonces[0:1], nonces[1:1], nonces[2:1], nonces[3:1], offset, 1, R136, SHAKE);
  offset = 0;
  out0, out1, out2, out3, _, st
    = A128::__squeeze_array_avx2x4(out0, out1, out2, out3, offset, 128, st, R136);

  return out0, out1, out2, out3;
}

fn _shake128_absorb_A32_A2
( reg const ptr u8[32] seed
, reg const ptr u8[2] pos
) -> reg u256[7]
{ reg u256[7] st;
  stack u64[25] pst_s;
  reg ptr u64[25] pst;
  reg u64 offset;
  pst = pst_s;
  pst, st = __pstate_init_avx2(pst);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 0, st, seed, offset, 32, R168, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A2::__pabsorb_array_avx2(pst, 32, st, pos, offset, 2, R168, SHAKE);

  return st;
}

fn _shake128x4_absorb_A32_A2
( reg mut ptr u256[25] st
, reg const ptr u8[32] seed
, reg const ptr u8[4*2] pos
) -> reg ptr u256[25]
{ inline int AT;
  reg u64 offset;
  st = __state_init_avx2x4(st);
  offset = 0;
  st, AT, _ = A32::__absorb_bcast_array_avx2x4(st, 0, seed, offset, 32, R168, UNFINISHED);
  offset = 0;
  st, _, _ = A2::__absorb_array_avx2x4(st, AT, pos[0:2], pos[2:2], pos[4:2], pos[6:2], offset, 2, R168, SHAKE);

  return st;
}

fn _shake128_squeeze3blocks
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
, reg u256[7] st
) -> reg ptr u8[ABUFLEN::_ASIZE]
{
 reg u64 offset;
 st = _keccakf1600_avx2(st);
 offset = 0;
 buf, offset = ABUFLEN::__dumpstate_array_avx2(buf, offset, R168, st);
 st = _keccakf1600_avx2(st);
 buf, offset = ABUFLEN::__dumpstate_array_avx2(buf, offset, R168, st);
 st = _keccakf1600_avx2(st);
 buf, offset = ABUFLEN::__dumpstate_array_avx2(buf, offset, 200, st);
 return buf;
}

fn _shake128_next_state
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
) -> reg ptr u8[ABUFLEN::_ASIZE] /* buf */
{
 reg u256[7] st;
 reg ptr u64[25] pst;
 reg u64 offset;
 pst = buf[:u64 2*(168/8) : 25];
 st = __state_from_pstate_avx2(pst);
 st = _keccakf1600_avx2(st);
 offset = 2*168;
 buf, _ = ABUFLEN::__dumpstate_array_avx2(buf, offset, 200, st);
 return buf;
}

fn _shake128x4_squeeze3blocks
( reg mut ptr u256[25] st
, reg mut ptr u8[4*ABUFLEN::_ASIZE] buf
) -> reg ptr u256[25]
   , reg ptr u8[4*ABUFLEN::_ASIZE] /* buf */
{
 reg ptr u8[ABUFLEN::_ASIZE] buf0 buf1 buf2 buf3;
 reg u64 offset;
 buf0 = buf[0*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf1 = buf[1*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf2 = buf[2*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 buf3 = buf[3*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE];
 offset = 0;
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_array_avx2x4(buf0, buf1, buf2, buf3, offset, R168, st);
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_array_avx2x4(buf0, buf1, buf2, buf3, offset, R168, st);
 st = _keccakf1600_avx2x4(st);
 buf0, buf1, buf2, buf3, offset
  = ABUFLEN::__dumpstate_array_avx2x4(buf0, buf1, buf2, buf3, offset, 200, st);
 buf[0*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf0;
 buf[1*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf1;
 buf[2*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf2;
 buf[3*ABUFLEN::_ASIZE : ABUFLEN::_ASIZE] = buf3;

 return st, buf;
}

fn _sha3_256A_A1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1184] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  st, _ = A1184::__absorb_array_avx2(st, in, 0, 1184, R136, SHA3);
  offset = 0;
  out, _ = A32::__squeeze_array_avx2(out, offset, 32, st, R136);

  return out;
}

fn _sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1568] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  st, _ = A1568::__absorb_array_avx2(st, in, 0, 1568, R136, SHA3);
  offset = 0;
  out, _ = A32::__squeeze_array_avx2(out, offset, 32, st, R136);

  return out;
}

fn _shake256_A32__A1120
(  reg mut ptr u8[32] out
,  reg const ptr u8[1120] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  offset = 0;
  st, _ = A1120::__absorb_array_avx2(st, in, offset, 1120, R136, SHAKE);
  offset = 0;
  out, _ = A32::__squeeze_array_avx2(out, offset, 32, st, R136);
  return out;
}

fn _shake256_A32__A1600
(  reg mut ptr u8[32] out
,  reg const ptr u8[1600] in
) -> reg ptr u8[32]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  offset = 0;
  st, _ = A1600::__absorb_array_avx2(st, in, offset, 1600, R136, SHAKE);
  offset = 0;
  out, _ = A32::__squeeze_array_avx2(out, offset, 32, st, R136);
  return out;
}

} // namespace OLD


// SELECTION:

inline fn _sha3_512A_A33
( #spill_to_mmx reg mut ptr u8[64] out
, reg const ptr u8[33] in
) -> reg ptr u8[64]
{
  out = OLD::_sha3_512A_A33(out, in);
  return out;
}

inline fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{
  out = OLD::_sha3_512A_A64(out, in);
  return out;
}

inline fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ 
  out = OLD::_shake256_A128__A32_A1(out, seed, nonce);
  return out;
}

inline fn _shake256x4_A128__A32_A1
( reg mut ptr u8[128] out0 out1 out2 out3
, reg const ptr u8[32] seed
, reg const ptr u8[4] nonces
) -> reg ptr u8[128] /* out0 */
   , reg ptr u8[128] /* out1 */
   , reg ptr u8[128] /* out2 */
   , reg ptr u8[128] /* out3 */
{ 
  out0, out1, out2, out3 = OLD::_shake256x4_A128__A32_A1(out0, out1, out2, out3, seed, nonces);
  return out0, out1, out2, out3;
}

inline fn _shake128_absorb_A32_A2
( reg const ptr u8[32] seed
, reg const ptr u8[2] pos
) -> reg u256[7]
{
  reg u256[7] st;
  st = OLD::_shake128_absorb_A32_A2(seed, pos);
  return st;
}

inline fn _shake128x4_absorb_A32_A2
( reg mut ptr u256[25] st
, reg const ptr u8[32] seed
, reg const ptr u8[4*2] pos
) -> reg ptr u256[25]
{ 
  st = OLD::_shake128x4_absorb_A32_A2(st, seed, pos);
  return st;
}

inline fn _shake128_squeeze3blocks
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
, reg u256[7] st
) -> reg ptr u8[ABUFLEN::_ASIZE]
{
  buf = OLD::_shake128_squeeze3blocks(buf, st);
  return buf;
}

inline fn _shake128_next_state
( reg mut ptr u8[ABUFLEN::_ASIZE] buf
) -> reg ptr u8[ABUFLEN::_ASIZE] /* buf */
{
  buf = OLD::_shake128_next_state(buf);
  return buf;
}

inline fn _shake128x4_squeeze3blocks
( reg mut ptr u256[25] st
, reg mut ptr u8[4*ABUFLEN::_ASIZE] buf
) -> reg ptr u256[25]
   , reg ptr u8[4*ABUFLEN::_ASIZE] /* buf */
{
  st, buf = OLD::_shake128x4_squeeze3blocks(st, buf);
  return st, buf;
}

inline fn _sha3_256A_A1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1184] in
) -> reg ptr u8[32]
{
  out = OLD::_sha3_256A_A1184(out, in);
  return out;
}

inline fn _sha3_256A_A1568
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg const ptr u8[1568] in
) -> reg ptr u8[32]
{
  out = OLD::_sha3_256A_A1568(out, in);
  return out;
}

inline fn _shake256_A32__A1120
(  reg mut ptr u8[32] out
,  reg const ptr u8[1120] in
) -> reg ptr u8[32]
{
  out = OLD::_shake256_A32__A1120(out, in);
  return out;
}

inline fn _shake256_A32__A1600
(  reg mut ptr u8[32] out
,  reg const ptr u8[1600] in
) -> reg ptr u8[32]
{ 
  out = OLD::_shake256_A32__A1600(out, in);
  return out;
}

