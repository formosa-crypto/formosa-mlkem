require "params.jinc"
require "../../common/ref/poly.jinc"

fn _i_poly_compress(reg mut ptr u8[MLKEM_POLYCOMPRESSEDBYTES] rp, reg mut ptr u16[MLKEM_N] a) -> reg ptr u8[MLKEM_POLYCOMPRESSEDBYTES], reg ptr u16[MLKEM_N]
requires {is_arr_init(a,0,2*MLKEM_N)}
ensures {is_arr_init(result.0,0,MLKEM_POLYCOMPRESSEDBYTES) && is_arr_init(result.1,0,2*MLKEM_N)}{
  reg u16 u;
  reg u32 d0;
  reg ui64 i k;
  reg u8[8] t;
  reg u8 c0 c1 c2;
  inline int j;

  a = _poly_csubq(a);

  k = 0;
  i = 0;
  while(i < MLKEM_N)
  {
    for j = 0 to 8
    {
      u = (16u)a[i+j];
      d0 = (32u)u;
      d0 <<= 5;
      d0 += 1664;
      d0 *= 40318;
      d0 >>= 27;
      d0 &= 0x1f;
      t[j] = d0;
    }

    c0 = t[0];
    c1 = t[1];
    c1 <<= 5;
    c0 |= c1;
    rp[k] = c0;

    c0 = t[1];
    c0 >>= 3;
    c1 = t[2];
    c1 <<= 2;
    c2 = t[3];
    c2 <<= 7;
    c0 |= c1;
    c0 |= c2;
    rp[k+1] = c0;

    c0 = t[3];
    c0 >>= 1;
    c1 = t[4];
    c1 <<= 4;
    c0 |= c1;
    rp[k+2] = c0;

    c0 = t[4];
    c0 >>= 4;
    c1 = t[5];
    c1 <<= 1;
    c2 = t[6];
    c2 <<= 6;
    c0 |= c1;
    c0 |= c2;
    rp[k+3] = c0;

    c0 = t[6];
    c0 >>= 2;
    c1 = t[7];
    c1 <<= 3;
    c0 |= c1;
    rp[k+4] = c0;

    k += 5;
    i += 8;
  }
  return rp, a;
}


fn _i_poly_decompress(reg mut ptr u16[MLKEM_N] rp, reg const ptr u8[MLKEM_POLYCOMPRESSEDBYTES] ap) -> reg ptr u16[MLKEM_N]
requires {is_arr_init(ap,0,MLKEM_POLYCOMPRESSEDBYTES)}
ensures {is_arr_init(result.0,0,2*MLKEM_N)}
{
  reg u8[8] t;
  reg u8 c0, c1, c2;
  reg u32 d0;
  reg ui64 i, j;
  inline int k;

  j = 0;
  i = 0;

  while (i < MLKEM_N) {
    c0 = ap[j];
    t[0] = c0;
    j += 1;

    c0 >>= 5;
    c1 = ap[j];
    c2 = c1;
    c1 <<= 3;
    c0 |= c1;
    t[1] = c0;
    j += 1;

    c1 = c2;
    c1 >>= 2;
    t[2] = c1;

    c1 >>= 5;
    c0 = ap[j];
    c2 = c0;
    c0 <<= 1;
    c0 |= c1;
    t[3] = c0;
    j += 1;

    c1 = c2;
    c1 >>= 4;
    c0 = ap[j];
    c2 = c0;
    c0 <<= 4;
    c0 |= c1;
    t[4] = c0;
    j += 1;

    c1 = c2;
    c1 >>= 1;
    t[5] = c1;

    c1 >>= 5;
    c0 = ap[j];
    c2 = c0;
    c0 <<= 2;
    c0 |= c1;
    t[6] = c0;
    j += 1;

    c2 >>= 3;
    t[7] = c2;

    for k = 0 to 8
    {
      d0 = (32u)t[k];
      d0 &= 31;
      d0 *= MLKEM_Q;
      d0 += 16;
      d0 >>= 5;
      rp[i+k] = d0;
    }
    i += 8;
  }
  return rp;
}
