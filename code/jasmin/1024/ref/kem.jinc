require "params.jinc"
require "poly.jinc"
require "polyvec.jinc"
require "../../common/ref/gen_matrix.jinc"
require "../../common/ref/indcpa.jinc"
require "../../common/ref/verify.jinc"

inline
fn __crypto_kem_keypair_jazz(reg mut ptr u8[MLKEM_PUBLICKEYBYTES] pk, reg mut ptr u8[MLKEM_SECRETKEYBYTES] sk, reg const ptr u8[MLKEM_SYMBYTES*2] randomnessp) -> reg ptr u8[MLKEM_PUBLICKEYBYTES], reg ptr u8[MLKEM_SECRETKEYBYTES]
{
  stack u8[32] h_pk;
  #mmx stack ptr u8[MLKEM_SECRETKEYBYTES] s_skp;
  #mmx reg ptr u8[MLKEM_SYMBYTES*2] s_randomnessp;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp1 randomnessp2;
  reg u64 t64;
  inline int i;
  reg ptr u8[MLKEM_POLYVECBYTES] icsk;

  s_randomnessp = randomnessp;
  randomnessp1 = randomnessp[0:MLKEM_SYMBYTES];
  
  icsk = sk[0:MLKEM_POLYVECBYTES]; s_skp = sk;
  pk, icsk = __indcpa_keypair(pk, icsk, randomnessp1);
  sk = s_skp; sk[0:MLKEM_POLYVECBYTES] = icsk;

  for i = 0 to MLKEM_INDCPA_PUBLICKEYBYTES/8
  {
    t64 = pk[:u64 i];
    sk.[:u64 (MLKEM_POLYVECBYTES/8 + i)*8] = t64;
  }

  s_skp = sk;

  h_pk = _sha3_256A_A1568(h_pk, pk);

  sk = s_skp;

  for i = 0 to 4
  {
    t64 = h_pk[:u64 i];
    sk.[:u64 ((MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES)/8 + i)*8] = t64;
  }

  randomnessp = s_randomnessp;
  randomnessp2 = randomnessp[MLKEM_SYMBYTES:MLKEM_SYMBYTES];

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp2.[:u64 i*8];
    sk.[:u64 ((MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES + MLKEM_SYMBYTES)/8 + i)*8] = t64;
  }

  return pk, sk;
}

inline
fn __crypto_kem_enc_jazz(reg mut ptr u8[MLKEM_CIPHERTEXTBYTES] ct, reg mut ptr u8[MLKEM_SYMBYTES] shk, reg const ptr u8[MLKEM_PUBLICKEYBYTES] pk, reg const ptr u8[MLKEM_SYMBYTES] randomnessp) -> reg ptr u8[MLKEM_CIPHERTEXTBYTES], reg ptr u8[MLKEM_SYMBYTES]
{
  inline int i;

  stack u8[MLKEM_SYMBYTES * 2] buf kr;
  stack ptr u8[MLKEM_PUBLICKEYBYTES] s_pk;
  stack ptr u8[MLKEM_CIPHERTEXTBYTES] s_ct;
  stack ptr u8[MLKEM_SYMBYTES] s_shk;
  reg u64 t64;

  s_pk = pk;
  s_ct = ct;
  s_shk = shk;

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp[:u64 i];
    buf[:u64 i] = t64;
  }

  buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES] = _sha3_256A_A1568(buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES], pk);

  kr = _sha3_512A_A64(kr, buf);

  pk = s_pk;

  ct = __indcpa_enc(ct, buf[0:MLKEM_INDCPA_MSGBYTES], pk, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  shk = s_shk;

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = kr[:u64 i];
    shk[:u64 i] = t64;
  }

  return ct, shk;
}

inline
fn __crypto_kem_dec_jazz(reg mut ptr u8[MLKEM_SYMBYTES] shk, reg const ptr u8[MLKEM_CIPHERTEXTBYTES] ct, reg const ptr u8[MLKEM_SECRETKEYBYTES] sk) -> reg ptr u8[MLKEM_SYMBYTES]
{
  stack u8[MLKEM_INDCPA_CIPHERTEXTBYTES] ctc;
  stack u8[2*MLKEM_SYMBYTES] kr buf;
  stack u8[MLKEM_SECRETKEYBYTES] s_sk;
  #mmx stack ptr u8[MLKEM_CIPHERTEXTBYTES] s_ct;
  #mmx stack ptr u8[MLKEM_SYMBYTES] s_shk;
  #mmx reg u64 s_cnd;
  reg u64 cnd;
  reg u64 t64;
  inline int i;

  s_shk = shk;
  s_ct = ct;
  s_sk = sk;

  buf[0:MLKEM_INDCPA_MSGBYTES] = __indcpa_dec(buf[0:MLKEM_INDCPA_MSGBYTES], ct, s_sk[0:MLKEM_POLYVECBYTES]);

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = s_sk.[:u64 (i + (MLKEM_SECRETKEYBYTES-2*MLKEM_SYMBYTES)/8)*8];
    buf.[:u64 (i + MLKEM_SYMBYTES/8)*8] = t64;
  }

  kr = _sha3_512A_A64(kr, buf);

  ctc = __indcpa_enc(ctc, buf[0:MLKEM_SYMBYTES], s_sk[MLKEM_POLYVECBYTES:MLKEM_PUBLICKEYBYTES], kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  ct = s_ct;

  cnd = __verify(ct, ctc);
  s_cnd = cnd; 

  ct = s_ct;

  shk = s_shk;

  shk = _shake256_A32__A1600(shk, s_sk[MLKEM_SECRETKEYBYTES-MLKEM_SYMBYTES:MLKEM_SYMBYTES], ct);

  s_shk = shk;
  cnd = s_cnd;

  shk = __cmov(shk, kr[0:MLKEM_SYMBYTES], cnd);
  return shk;
}
