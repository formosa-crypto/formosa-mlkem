require "kem.jinc"

#[ct = "secret × secret × secret → secret × secret × public"]
export fn jade_kem_mlkem_mlkem1024_amd64_ref_keypair_derand(
    #spill_to_mmx reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
    #spill_to_mmx reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key,
    #spill_to_mmx reg ptr u8[2*MLKEM_SYMBYTES] coins)
 -> reg ptr u8[MLKEM_PUBLICKEYBYTES], reg ptr u8[MLKEM_SECRETKEYBYTES], reg u64
requires{is_arr_init(coins,0,2*MLKEM_SYMBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_PUBLICKEYBYTES) && is_arr_init(result.1,0,MLKEM_SECRETKEYBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_PUBLICKEYBYTES] pk;
  reg ptr u8[MLKEM_PUBLICKEYBYTES] pkp;
  stack u8[MLKEM_SECRETKEYBYTES] sk;
  reg ptr u8[MLKEM_SECRETKEYBYTES] skp;

  stack u8[2*MLKEM_SYMBYTES] rd;
  reg ptr u8[2*MLKEM_SYMBYTES] rdp;
  _ = #init_msf();

  () = #spill(public_key);
  () = #spill(secret_key);

  rd = #copy(coins);

  pkp = pk;
  skp = sk;
  rdp = rd;

  pkp, skp = __crypto_kem_keypair_jazz(pkp, skp, rdp);

  () = #unspill(public_key);
  () = #unspill(secret_key);

  pk = pkp;
  sk = skp;

  public_key = #copy(pk);
  secret_key = #copy(sk);

  () = #spill(public_key);
  () = #spill(secret_key);

  ?{}, r = #set0();
  return public_key, secret_key, r;
}

#[ct = "secret × secret → secret × secret × public"]
export fn jade_kem_mlkem_mlkem1024_amd64_ref_keypair(
  #spill_to_mmx reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
  #spill_to_mmx reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key)
 -> reg ptr u8[MLKEM_PUBLICKEYBYTES], reg ptr u8[MLKEM_SECRETKEYBYTES], reg u64
ensures{is_arr_init(result.0,0,MLKEM_PUBLICKEYBYTES) && is_arr_init(result.1,0,MLKEM_SECRETKEYBYTES)}
{
  reg u64 r;
  stack u8[2*MLKEM_SYMBYTES] rd;
  reg ptr u8[2*MLKEM_SYMBYTES] rdp;
  public_key = public_key;
  secret_key = secret_key;
  rd = #randombytes(rd);
  rdp = rd;
  public_key,secret_key,r = jade_kem_mlkem_mlkem1024_amd64_ref_keypair_derand(public_key,secret_key,rdp);
  return public_key,secret_key,r;
}

#[ct = "secret × secret × secret × secret → secret × secret × public"]
export fn jade_kem_mlkem_mlkem1024_amd64_ref_enc_derand(
    #spill_to_mmx reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    #spill_to_mmx reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    #spill_to_mmx reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
    #spill_to_mmx reg ptr u8[MLKEM_SYMBYTES] coins)
    -> reg ptr u8[MLKEM_CIPHERTEXTBYTES], reg ptr u8[MLKEM_SYMBYTES], reg u64
requires{is_arr_init(coins,0,MLKEM_SYMBYTES) && is_arr_init(public_key,0,MLKEM_PUBLICKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(result.1,0,MLKEM_SYMBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_CIPHERTEXTBYTES] ct;
  reg ptr u8[MLKEM_CIPHERTEXTBYTES] ctp;
  stack u8[MLKEM_SYMBYTES] shk;
  reg ptr u8[MLKEM_SYMBYTES] shkp;
  stack u8[MLKEM_PUBLICKEYBYTES] pk;
  reg ptr u8[MLKEM_PUBLICKEYBYTES] pkp;

  stack u8[MLKEM_SYMBYTES] rd;
  reg ptr u8[MLKEM_SYMBYTES] rdp;

  _ = #init_msf();

  () = #spill(ciphertext);
  () = #spill(shared_secret);
  pk =  #copy(public_key);
  rd =  #copy(coins);

  ctp = ct;
  pkp = pk;
  shkp = shk;
  rdp = rd;

  ctp, shkp =__crypto_kem_enc_jazz(ctp, shkp, pkp, rdp);

  () = #unspill(ciphertext);
  () = #unspill(shared_secret);

  ct = ctp;
  shk = shkp;

  ciphertext = #copy(ct);
  shared_secret = #copy(shk);

  ?{}, r = #set0();
  return ciphertext, shared_secret, r;
}


#[ct = "secret × secret × secret → secret × secret × public"]
export fn jade_kem_mlkem_mlkem1024_amd64_ref_enc(
    #spill_to_mmx reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    #spill_to_mmx reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    #spill_to_mmx reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key)
    -> reg ptr u8[MLKEM_CIPHERTEXTBYTES], reg ptr u8[MLKEM_SYMBYTES], reg u64
requires{is_arr_init(public_key,0,MLKEM_PUBLICKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(result.1,0,MLKEM_SYMBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES] rd;
  reg ptr u8[MLKEM_SYMBYTES] rdp;
  ciphertext = ciphertext;
  shared_secret = shared_secret;
  public_key = public_key;
  rd = #randombytes(rd);
  rdp = rd;
  ciphertext, shared_secret, r = jade_kem_mlkem_mlkem1024_amd64_ref_enc_derand(ciphertext,shared_secret,public_key,rdp);
  return ciphertext, shared_secret, r;
}

#[ct = "secret × secret × secret → secret × public"]
export fn jade_kem_mlkem_mlkem1024_amd64_ref_dec(
    #spill_to_mmx reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key)
    -> reg ptr u8[MLKEM_SYMBYTES], reg u64
requires{is_arr_init(ciphertext,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(secret_key,0,MLKEM_SECRETKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_SYMBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES] shk;
  reg ptr u8[MLKEM_SYMBYTES] shkp;
  stack u8[MLKEM_SECRETKEYBYTES] sk;
  reg ptr u8[MLKEM_SECRETKEYBYTES] skp;
  stack u8[MLKEM_CIPHERTEXTBYTES] ct;
  reg ptr u8[MLKEM_CIPHERTEXTBYTES] ctp;

  _ = #init_msf();

  () = #spill(shared_secret);

  ct =  #copy(ciphertext);
  sk =  #copy(secret_key);

  ctp = ct;
  shkp = shk;
  skp = sk;

  shkp = __crypto_kem_dec_jazz(shkp, ctp, skp);

  () = #unspill(shared_secret);

  shk = shkp;

  shared_secret = #copy(shk);

  ?{}, r = #set0();
  return shared_secret, r;
}
