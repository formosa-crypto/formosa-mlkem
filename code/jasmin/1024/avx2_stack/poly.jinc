require "../avx2/params.jinc"
require "../../common/avx2_stack/poly.jinc"

u16 pc_mask_s = 0x1F;
u16 pc_shift1_s = 0x400;
u16 pc_shift2_s = 0x2001;
u32 pc_shift3_s = 0x4000001;
u64 pc_sllvdidx_s = 0xC;
u8[32] pc_shufbidx_s = { 0, 1, 2, 3, 4,-1,-1,-1,-1,-1, 8, 9,10,11,12,-1,
                         9,10,11,12,-1, 0, 1, 2, 3, 4,-1,-1,-1,-1,-1, 8 };
inline
fn _i_poly_compress(reg ptr u8[MLKEM_POLYCOMPRESSEDBYTES] rp, reg ptr u16[MLKEM_N] a) -> reg ptr u8[MLKEM_POLYCOMPRESSEDBYTES], reg ptr u16[MLKEM_N]
{
  inline int i;
  reg u256 f0 f1 v mask shift1 shift2 shift3 sllvdidx shufbidx;
  reg ptr u16[16] x16p;
  reg u128 t0 t1;

  a = _poly_csubq(a);

  x16p = jvx16;
  v = x16p[u256 0];
  shift1 = #VPBROADCAST_16u16(pc_shift1_s);
  mask = #VPBROADCAST_16u16(pc_mask_s);
  shift2 = #VPBROADCAST_16u16(pc_shift2_s);
  shift3 = #VPBROADCAST_8u32(pc_shift3_s);
  sllvdidx = #VPBROADCAST_4u64(pc_sllvdidx_s);
  shufbidx = pc_shufbidx_s[u256 0];

  for i = 0 to MLKEM_N/32
  {
    f0 = a[u256 2*i];
    f1 = a[u256 2*i + 1];
    f0 = #VPMULH_16u16(f0, v);
    f1 = #VPMULH_16u16(f1, v);
    f0 = #VPMULHRS_16u16(f0, shift1);
    f1 = #VPMULHRS_16u16(f1, shift1);
    f0 = #VPAND_256(f0, mask);
    f1 = #VPAND_256(f1, mask);
    f0 = #VPACKUS_16u16(f0, f1);
    f0 = #VPMADDUBSW_256(f0, shift2);
    f0 = #VPMADDWD_256(f0, shift3);
    f0 = #VPSLLV_8u32(f0, sllvdidx);
    f0 = #VPSRLV_4u64(f0, sllvdidx);
    f0 = #VPSHUFB_256(f0, shufbidx);
    t0 = (128u)f0;
    t1 = #VEXTRACTI128(f0, 1);
    t0 = #VPBLENDVB_128(t0, t1, (128u)shufbidx);
    rp.[u128 20*i] = t0;
    rp.[u32 20*i + 16] = (32u)t1;
  }

  return rp, a;
}

u8[32] pd_jshufbidx = {0,0,0,1,1,1,1,2,2,3,3,3,3,4,4,4,
                       5,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9};
u16[16] pd_mask_s = {31,992,124,3968,496,62,1984,248,
                     31,992,124,3968,496,62,1984,248};
u16[16] pd_shift_s = {1024,32,256,8,64,512,16,128,
                      1024,32,256,8,64,512,16,128};

fn _i_poly_decompress(reg mut ptr u16[MLKEM_N] rp, reg ptr u8 [MLKEM_POLYCOMPRESSEDBYTES] a) -> reg ptr u16[MLKEM_N]
{
  inline int i;
  reg u256 f q shufbidx mask shift;
  reg u128 t;
  reg u16 ti;
  reg ptr u16[16] x16p;
  stack u128 sh;

  x16p = jqx16;
  q = x16p[u256 0];
  shufbidx = pd_jshufbidx[u256 0];
  mask = pd_mask_s[u256 0];
  shift = pd_shift_s[u256 0];

  f = #set0_256();

  for i = 0 to MLKEM_N/16
  {
    t = (128u)a.[u64 10*i];
    ti = (16u)a.[u16 10*i + 8];
    t = #VPINSR_8u16(t, ti, 4);
    sh = t;
    f = #VPBROADCAST_2u128(sh);

    f = #VPSHUFB_256(f, shufbidx);
    f = #VPAND_256(f, mask);
    f = #VPMULL_16u16(f, shift);
    f = #VPMULHRS_16u16(f, q);
    rp[u256 i] = f;
  }

  return rp;
}
