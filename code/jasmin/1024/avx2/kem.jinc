require "indcpa.jinc"
require "../../common/avx2/verify.jinc"

#[safety =
   { requires = is_arr_init(randomnessp,0,MLKEM_SYMBYTES*2)
   , ensures = is_arr_init(result.0,0,MLKEM_PUBLICKEYBYTES) && is_arr_init(result.1,0,MLKEM_SECRETKEYBYTES)
   }
 ]
inline
fn __crypto_kem_keypair_jazz(reg ptr u8[MLKEM_PUBLICKEYBYTES] pk, reg ptr u8[MLKEM_SECRETKEYBYTES] sk, reg ptr u8[MLKEM_SYMBYTES*2] randomnessp) -> reg ptr u8[MLKEM_PUBLICKEYBYTES], reg ptr u8[MLKEM_SECRETKEYBYTES]
{
  #[mmx] reg ptr u8[MLKEM_SYMBYTES*2] s_randomnessp;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp1;
  reg u64 t64;
  inline int i;
  reg ptr u8[MLKEM_POLYVECBYTES] skcpa;
  #[mmx] reg ptr u8[MLKEM_SECRETKEYBYTES]sk_s;

  s_randomnessp = randomnessp;

  randomnessp1 = randomnessp[0:MLKEM_SYMBYTES];
  skcpa = sk[0:MLKEM_POLYVECBYTES]; sk_s = sk; 
  pk, skcpa = __indcpa_keypair(pk, skcpa, randomnessp1);
  sk = sk_s; sk[0:MLKEM_POLYVECBYTES] = skcpa; 

  for i = 0 to MLKEM_INDCPA_PUBLICKEYBYTES/8
  {
    t64 = pk[:u64 i];
    sk.[:u64 (MLKEM_POLYVECBYTES/8 + i)*8] = t64;
  }

  sk[MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES:32] = _sha3_256A_A1568(sk[MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES:32], pk);

  randomnessp = s_randomnessp;

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp[:u64 MLKEM_SYMBYTES/8 + i];
    sk.[:u64 ((MLKEM_POLYVECBYTES + MLKEM_PUBLICKEYBYTES + MLKEM_SYMBYTES)/8 + i)*8] = t64;
  }

  return pk, sk;
}

#[safety =
   { requires = is_arr_init(randomnessp,0,MLKEM_SYMBYTES) && is_arr_init(pk,0,MLKEM_PUBLICKEYBYTES)
   , ensures = is_arr_init(result.0,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(result.1,0,MLKEM_SYMBYTES)
   }
 ]
inline
fn __crypto_kem_enc_jazz(
  reg ptr u8[MLKEM_CIPHERTEXTBYTES] ct,
  #[spill_to_mmx] reg ptr u8[MLKEM_SYMBYTES] shk,
  #[spill_to_mmx] reg ptr u8[MLKEM_PUBLICKEYBYTES] pk,
  reg ptr u8[MLKEM_SYMBYTES] randomnessp)
  -> reg ptr u8[MLKEM_CIPHERTEXTBYTES], reg ptr u8[MLKEM_SYMBYTES]
{
  stack u8[MLKEM_SYMBYTES * 2] buf kr;

  () = #spill(pk, shk);

  buf[0:MLKEM_SYMBYTES] = #copy(randomnessp);

  buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES] = _sha3_256A_A1568(buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES], pk);

  kr = _sha3_512A_A64(kr, buf);

  () = #unspill(pk);

  ct = __indcpa_enc(ct, buf[0:MLKEM_INDCPA_MSGBYTES], pk, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  () = #unspill(shk);

  shk = #copy(kr[0:MLKEM_SYMBYTES]);

  return ct, shk;
}

#[safety =
   { requires = is_arr_init(ct,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(sk,0,MLKEM_SECRETKEYBYTES)
   , ensures = is_arr_init(result.0,0,MLKEM_SYMBYTES)
   }
 ]
inline
fn __crypto_kem_dec_jazz(
  #[spill_to_mmx] reg ptr u8[MLKEM_SYMBYTES] shk,
  #[spill_to_mmx] reg ptr u8[MLKEM_CIPHERTEXTBYTES] ct,
  #[spill_to_mmx] reg ptr u8[MLKEM_SECRETKEYBYTES] sk)
  -> reg ptr u8[MLKEM_SYMBYTES]
{
  stack u8[MLKEM_INDCPA_CIPHERTEXTBYTES] ctc;
  stack u8[2*MLKEM_SYMBYTES] kr buf;
  stack u8[MLKEM_SYMBYTES + MLKEM_CIPHERTEXTBYTES] zp_ct; // used instead of reg u64 zp
  reg u64 cnd;

  () = #spill(shk, ct);
  zp_ct[0:MLKEM_SYMBYTES] = #copy(sk[MLKEM_SECRETKEYBYTES - MLKEM_SYMBYTES : MLKEM_SYMBYTES]);

  buf[0:MLKEM_INDCPA_MSGBYTES] = __indcpa_dec(buf[0:MLKEM_INDCPA_MSGBYTES], ct, sk[0:MLKEM_POLYVECBYTES]);

  // we do not need to do pointer arithmetic here

  /* fixme: should loads be 256-bits long? */
  buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES] = #copy(sk[MLKEM_INDCPA_SECRETKEYBYTES + MLKEM_INDCPA_PUBLICKEYBYTES:MLKEM_SYMBYTES]);

  //kr = _sha3_512_64(kr, buf);
  kr = _sha3_512A_A64(kr, buf);

  // No need for pointer arithmetic

  ctc = __indcpa_enc(ctc, buf[0:MLKEM_SYMBYTES], sk[MLKEM_POLYVECBYTES:MLKEM_PUBLICKEYBYTES], kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  () = #unspill(ct);

  cnd = __verify(ct, ctc);

  // No need for pointer arithmetic, but we will need to do some copying then as reg ptr = reg ptr is a noop
  // And concating both zp and ctp to make the SHAKE function easier to implement, read and understand

  zp_ct[MLKEM_SYMBYTES:MLKEM_CIPHERTEXTBYTES] = #copy(ct);

  /* fixme: should this be done in memory? */
  () = #unspill(shk);

  shk = _shake256_A32__A1600(shk, zp_ct);

  shk = __cmov(shk, kr[0:MLKEM_SYMBYTES], cnd);
  return shk;
}
