require "params.jinc"
require "poly.jinc"
require "polyvec.jinc"
require "gen_matrix.jinc"

inline
fn __indcpa_keypair(reg u32 spkp, reg u32 sskp, reg ptr u8[MLKEM_SYMBYTES] randomnessp)
{
  stack u16[MLKEM_K * MLKEM_VECN] a;
  stack u16[MLKEM_VECN] e pkpv skpv;
  stack u8[64] buf;
  stack u8[MLKEM_SYMBYTES] publicseed noiseseed;
  reg ptr u8[MLKEM_SYMBYTES] r_noiseseed;
  reg ptr u8[MLKEM_SYMBYTES] s_noiseseed;
  stack u8[32] inbuf;
  reg u32 t32;
  reg u32 zero;
  reg u32 nonce;
  inline int i;

  stack u32 spkp_st;
  stack u32 sskp_st;

  spkp_st = spkp;
  sskp_st = sskp;

  for i=0 to MLKEM_SYMBYTES/4
  {
    t32 = (32u)randomnessp[u32 i];
    inbuf[u32 i] = t32;
  }

  buf = _sha3512_32(buf, inbuf);

  for i=0 to MLKEM_SYMBYTES/4
  {
    #[declassify]
    t32 = (32u)buf[u32 i];
    publicseed[u32 i] = t32;
    t32 = (32u)buf[u32 i + MLKEM_SYMBYTES/4];
    noiseseed[u32 i] = t32;
  }

  zero = 0; 
  a = __gen_matrix(publicseed, zero);

  nonce = 0;
  skpv[0:MLKEM_N] = _poly_getnoise(skpv[0:MLKEM_N], noiseseed, nonce);
  nonce = 1;
  skpv[MLKEM_N:MLKEM_N] = _poly_getnoise(skpv[MLKEM_N:MLKEM_N], noiseseed, nonce);
  nonce = 2;
  skpv[2*MLKEM_N:MLKEM_N] = _poly_getnoise(skpv[2*MLKEM_N:MLKEM_N], noiseseed, nonce);

  nonce = 3;
  e[0:MLKEM_N] = _poly_getnoise(e[0:MLKEM_N], noiseseed, nonce);
  nonce = 4;
  e[MLKEM_N:MLKEM_N] = _poly_getnoise(e[MLKEM_N:MLKEM_N], noiseseed, nonce);
  nonce = 5;
  e[2*MLKEM_N:MLKEM_N] = _poly_getnoise(e[2*MLKEM_N:MLKEM_N], noiseseed, nonce);

  skpv = __polyvec_ntt(skpv);
  e    = __polyvec_ntt(e);

  pkpv[0:MLKEM_N] = __polyvec_pointwise_acc(a[0:MLKEM_VECN], skpv);
  pkpv[0:MLKEM_N] = _poly_frommont(pkpv[0:MLKEM_N]);
  pkpv[MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(a[MLKEM_VECN:MLKEM_VECN], skpv);
  pkpv[MLKEM_N:MLKEM_N] = _poly_frommont(pkpv[MLKEM_N:MLKEM_N]);
  pkpv[2*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(a[2*MLKEM_VECN:MLKEM_VECN], skpv);
  pkpv[2*MLKEM_N:MLKEM_N] = _poly_frommont(pkpv[2*MLKEM_N:MLKEM_N]);

  pkpv = __polyvec_add2(pkpv, e);
  pkpv = __polyvec_reduce(pkpv);

  spkp = spkp_st;
  sskp = sskp_st;

  __polyvec_tobytes(sskp, skpv);
  __polyvec_tobytes(spkp, pkpv);

  spkp += MLKEM_POLYVECBYTES; 
  for i=0 to MLKEM_SYMBYTES/4
  {
    t32 = publicseed[u32 i];
    (u32)[spkp] = t32;
    spkp += 4;
  }
}

inline fn __indcpa_enc(reg u32 ctp, reg ptr u8[32] msgp, reg u32 pkp, reg ptr u8[MLKEM_SYMBYTES] coinsp)
{
  stack u16[MLKEM_K * MLKEM_VECN] at;
  stack u16[MLKEM_VECN] pkpv sp ep bp;
  stack u16[MLKEM_N] k poly epp v;
  stack u8[MLKEM_SYMBYTES] publicseed;
  reg ptr u8[MLKEM_SYMBYTES] publicseed_ptr;
  stack u8[MLKEM_SYMBYTES] noiseseed;
  reg ptr u8[MLKEM_SYMBYTES] noiseseed_ptr;
  reg u32 i j one;
  reg u32 t;
  reg u32 c nonce;
  stack u32 sctp;

  sctp = ctp;

  noiseseed_ptr = noiseseed;
  i = 0;
  while (i < MLKEM_SYMBYTES)
  {
    c = (32u)coinsp[i];
    noiseseed_ptr[i] = c;
    i += 1;
  }
  noiseseed = noiseseed_ptr;

  pkpv = __polyvec_frombytes(pkp);

  publicseed_ptr = publicseed;
  i = 0;
  pkp += MLKEM_POLYVECBYTES;
  while (i < MLKEM_SYMBYTES)
  {
    c = (32u)(u8)[pkp];
    publicseed_ptr[(int)i] = c;
    pkp += 1;
    i += 1;
  }
  publicseed = publicseed_ptr;

  k = _i_poly_frommsg(k, msgp);

  one = 1;
  at = __gen_matrix(publicseed, 1);

  nonce = 0;
  sp[0:MLKEM_N] = _poly_getnoise(sp[0:MLKEM_N], noiseseed, nonce);
  nonce = 1;
  sp[MLKEM_N:MLKEM_N] = _poly_getnoise(sp[MLKEM_N:MLKEM_N], noiseseed, nonce);
  nonce = 2;
  sp[2*MLKEM_N:MLKEM_N] = _poly_getnoise(sp[2*MLKEM_N:MLKEM_N], noiseseed, nonce);

  nonce = 3;
  ep[0:MLKEM_N] = _poly_getnoise(ep[0:MLKEM_N], noiseseed, nonce);
  nonce = 4;
  ep[MLKEM_N:MLKEM_N] = _poly_getnoise(ep[MLKEM_N:MLKEM_N], noiseseed, nonce);
  nonce = 5;
  ep[2*MLKEM_N:MLKEM_N] = _poly_getnoise(ep[2*MLKEM_N:MLKEM_N], noiseseed, nonce);

  nonce = 6;
  epp = _poly_getnoise(epp, noiseseed, nonce);

  sp = __polyvec_ntt(sp);
    
  bp[0:MLKEM_N] = __polyvec_pointwise_acc(at[0:MLKEM_VECN], sp);
  bp[MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(at[MLKEM_VECN:MLKEM_VECN], sp);
  bp[2*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(at[2*MLKEM_VECN:MLKEM_VECN], sp);
  
  v = __polyvec_pointwise_acc(pkpv, sp);

  bp = __polyvec_invntt(bp);
  v = _poly_invntt(v);

  bp = __polyvec_add2(bp, ep);
  v = _poly_add2(v, epp);
  v = _poly_add2(v, k);
  bp = __polyvec_reduce(bp);
  v  = __poly_reduce(v);

  ctp = sctp;
  __polyvec_compress(ctp, bp);
  ctp += MLKEM_POLYVECCOMPRESSEDBYTES;
  v = _poly_compress(ctp, v);
}

inline
fn __iindcpa_enc(reg ptr u8[MLKEM_CT_LEN] ctp, reg ptr u8[32] msgp, reg u32 pkp, reg ptr u8[MLKEM_SYMBYTES] noiseseed) -> reg ptr u8[MLKEM_CT_LEN]
{
  stack u16[MLKEM_VECN] pkpv sp ep bp;
  stack u16[MLKEM_K*MLKEM_VECN] aat;
  stack u16[MLKEM_N] k epp v;
  stack u8[MLKEM_SYMBYTES] publicseed;
  reg ptr u8[MLKEM_SYMBYTES] publicseed_ptr;
  reg u32 i t32;
  reg u32 nonce;
  stack ptr u8[MLKEM_CT_LEN] sctp;
  stack ptr u8[MLKEM_SYMBYTES] s_noiseseed;

  s_noiseseed = noiseseed;
  sctp = ctp;

  pkpv = __polyvec_frombytes(pkp);

  i = 0;
  pkp += MLKEM_POLYVECBYTES;
  publicseed_ptr = publicseed;
  while (i < MLKEM_SYMBYTES/4)
  {
    #[declassify]
    t32 = (32u)(u32)[pkp];
    publicseed_ptr.[u32 4*(int)i] = t32;
    pkp += 4;
    i += 1;
  }
  publicseed = publicseed_ptr;

  k = _i_poly_frommsg(k, msgp);

  aat = __gen_matrix(publicseed, 1);

  nonce = 0;
  sp[0:MLKEM_N] = _poly_getnoise(sp[0:MLKEM_N], s_noiseseed, nonce);

  nonce = 1;
  sp[MLKEM_N:MLKEM_N] = _poly_getnoise(sp[MLKEM_N:MLKEM_N], s_noiseseed, nonce);

  nonce = 2;
  sp[2*MLKEM_N:MLKEM_N] = _poly_getnoise(sp[2*MLKEM_N:MLKEM_N], s_noiseseed, nonce);

  nonce = 3;
  ep[0:MLKEM_N] = _poly_getnoise(ep[0:MLKEM_N], s_noiseseed, nonce);

  nonce = 4;
  ep[MLKEM_N:MLKEM_N] = _poly_getnoise(ep[MLKEM_N:MLKEM_N], s_noiseseed, nonce);

  nonce = 5;
  ep[2*MLKEM_N:MLKEM_N] = _poly_getnoise(ep[2*MLKEM_N:MLKEM_N], s_noiseseed, nonce);

  nonce = 6;
  epp = _poly_getnoise(epp, s_noiseseed, nonce);

  sp = __polyvec_ntt(sp);
    
  bp[0:MLKEM_N] = __polyvec_pointwise_acc(aat[0:MLKEM_VECN], sp);
  bp[MLKEM_N:MLKEM_N]= __polyvec_pointwise_acc(aat[MLKEM_VECN:MLKEM_VECN], sp);
  bp[2*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(aat[2*MLKEM_VECN:MLKEM_VECN], sp);
  
  v = __polyvec_pointwise_acc(pkpv, sp);

  bp = __polyvec_invntt(bp);
  v = _poly_invntt(v);

  bp = __polyvec_add2(bp, ep);
  v = _poly_add2(v, epp);
  v = _poly_add2(v, k);
  bp = __polyvec_reduce(bp);
  v  = __poly_reduce(v);

  ctp = sctp;
  ctp[0:MLKEM_POLYVECCOMPRESSEDBYTES] = __i_polyvec_compress(ctp[0:MLKEM_POLYVECCOMPRESSEDBYTES], bp);
  ctp[MLKEM_POLYVECCOMPRESSEDBYTES:MLKEM_POLYCOMPRESSEDBYTES], v = _i_poly_compress(ctp[MLKEM_POLYVECCOMPRESSEDBYTES:MLKEM_POLYCOMPRESSEDBYTES], v);

  return ctp;
}


inline
fn __indcpa_dec(reg ptr u8[MLKEM_MSGBYTES] msgp, reg u32 ctp, reg u32 skp) -> reg ptr u8[MLKEM_N/8]
{
  stack u16[MLKEM_N] t v mp;
  stack u16[MLKEM_VECN] bp skpv;

  bp = __polyvec_decompress(ctp);
  ctp += MLKEM_POLYVECCOMPRESSEDBYTES;
  v = _poly_decompress(v, ctp);


  skpv = __polyvec_frombytes(skp);
  
  bp = __polyvec_ntt(bp);
  t = __polyvec_pointwise_acc(skpv, bp);
  t = _poly_invntt(t );

  mp = _poly_sub(mp, v, t);
  mp = __poly_reduce(mp);

  () = #spill(ctp,skp);
  
  msgp, mp = _i_poly_tomsg(msgp, mp);

  () = #unspill(ctp,skp);


  return msgp;
}
