require "fips202.jinc"
require "params.jinc"

inline
fn __rej_uniform(stack u16[MLKEM_N] rp, reg u32 offset, stack u8[SHAKE128_RATE] buf) ->  reg u32, stack u16[MLKEM_N]
{
  reg u32 val1 val2;
  reg u32 t;
  reg u32 pos ctr aux; // aux is used to access buf when we do [pos+x], since the compiler says address computation is too complex
  reg ptr u8[SHAKE128_RATE] buf_ptr;
  reg ptr u16[MLKEM_N] rp_ptr;

  buf_ptr = buf;
  rp_ptr = rp;

  ctr = offset;
  pos = 0;

  while (pos < SHAKE128_RATE - 2) {

    if ctr < MLKEM_N {

      val1 = (32u)buf_ptr[pos];
      aux = pos + 1;
      t = (32u)buf_ptr[aux];
      val2 = t;
      val2 >>= 4;
      t &= 0x0F;
      t <<= 8;
      val1 |= t;

      aux = pos + 2;
      t = (32u)buf_ptr[aux];

      t <<= 4;
      val2 |= t;
      pos += 3;

      aux = MLKEM_Q;
      if val1 < aux {
        rp_ptr[ctr] = val1;
        ctr += 1;
      }

      if val2 < aux {
        if(ctr < MLKEM_N)
        {
          rp_ptr[ctr] = val2;
          ctr += 1;
        }
      }
    } else {
      pos = SHAKE128_RATE;
    }

  }

  rp = rp_ptr;

  return ctr, rp;

}

inline fn __gen_matrix(stack u8[MLKEM_SYMBYTES] seed, reg u32 transposed) -> stack u16[MLKEM_K*MLKEM_VECN]
{
  stack u8[34] extseed;
  stack u8[SHAKE128_RATE] buf;
  stack u32[25*2] state;
  stack u16[MLKEM_N] poly;
  stack u16[MLKEM_K*MLKEM_VECN] r;

  reg u32 c;
  reg u32 t;
  reg u32 ctr k;
  reg u32 sctr;
  reg u32 stransposed;
  reg u32 it;
  inline int j i;

  stransposed = transposed;

  for j = 0 to MLKEM_SYMBYTES/4
  {
    c = seed[u32 j];
    extseed[u32 j] = c;
  }

  for i=0 to MLKEM_K
  {
    for j=0 to MLKEM_K
    {
      transposed = stransposed;

      if(transposed == 0)
      {
        it = j;
        extseed[MLKEM_SYMBYTES] = it;
        it = i;
        extseed[MLKEM_SYMBYTES+1] = it;
      }
      else
      {
        it = i;
        extseed[MLKEM_SYMBYTES] = it;
        it = j;
        extseed[MLKEM_SYMBYTES+1] = it;
      }

      state = _shake128_absorb34(state, extseed);

      ctr = 0;
      while (ctr < MLKEM_N)
      {
        // TODO: find better way to free registers without spilling and unspilling 2
        () = #spill(ctr, stransposed); 
        state, buf = _shake128_squeezeblock(state, buf);
        () = #unspill(ctr, stransposed);
        ctr, poly  = __rej_uniform(poly, ctr, buf);
      }
      
      k = 0;
      reg ptr u16[MLKEM_N] rij;
      reg ptr u16[MLKEM_N] poly_reg; // Using poly makes the compiler complain that the access in t = (32u)poly[(int) k] complain that it is too complex
      poly_reg = poly;
      rij = r[i * MLKEM_VECN + j * MLKEM_N : MLKEM_N];
      while (k < MLKEM_N)
      {
        t = (32u)poly_reg[(int) k];
        rij[k] = t;
        k += 1;
      }
      poly = poly_reg;
      r[i * MLKEM_VECN + j * MLKEM_N : MLKEM_N] = rij;

    }
  }

  return r;
}