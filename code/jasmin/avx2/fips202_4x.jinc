///////////////////////////////////////////////////////////////////////////////
// TODO: when integrating in libjade, replace following statement with:
// from Jade require "common/keccak/keccak1600/amd64/spec/keccakf1600.jinc"

//require "keccakf1600.jinc" // r = __rhotates(x_, y_);

///////////////////////////////////////////////////////////////////////////////

require "fips202_common.jinc"



param int KECCAK_ROUNDS=24;

u256[24] KECCAK1600_RC_4x = {
  (4u64)[0x0000000000000001, 0x0000000000000001, 0x0000000000000001, 0x0000000000000001],
  (4u64)[0x0000000000008082, 0x0000000000008082, 0x0000000000008082, 0x0000000000008082],
  (4u64)[0x800000000000808a, 0x800000000000808a, 0x800000000000808a, 0x800000000000808a],
  (4u64)[0x8000000080008000, 0x8000000080008000, 0x8000000080008000, 0x8000000080008000],
  (4u64)[0x000000000000808b, 0x000000000000808b, 0x000000000000808b, 0x000000000000808b],
  (4u64)[0x0000000080000001, 0x0000000080000001, 0x0000000080000001, 0x0000000080000001],
  (4u64)[0x8000000080008081, 0x8000000080008081, 0x8000000080008081, 0x8000000080008081],
  (4u64)[0x8000000000008009, 0x8000000000008009, 0x8000000000008009, 0x8000000000008009],
  (4u64)[0x000000000000008a, 0x000000000000008a, 0x000000000000008a, 0x000000000000008a],
  (4u64)[0x0000000000000088, 0x0000000000000088, 0x0000000000000088, 0x0000000000000088],
  (4u64)[0x0000000080008009, 0x0000000080008009, 0x0000000080008009, 0x0000000080008009],
  (4u64)[0x000000008000000a, 0x000000008000000a, 0x000000008000000a, 0x000000008000000a],
  (4u64)[0x000000008000808b, 0x000000008000808b, 0x000000008000808b, 0x000000008000808b],
  (4u64)[0x800000000000008b, 0x800000000000008b, 0x800000000000008b, 0x800000000000008b],
  (4u64)[0x8000000000008089, 0x8000000000008089, 0x8000000000008089, 0x8000000000008089],
  (4u64)[0x8000000000008003, 0x8000000000008003, 0x8000000000008003, 0x8000000000008003],
  (4u64)[0x8000000000008002, 0x8000000000008002, 0x8000000000008002, 0x8000000000008002],
  (4u64)[0x8000000000000080, 0x8000000000000080, 0x8000000000000080, 0x8000000000000080],
  (4u64)[0x000000000000800a, 0x000000000000800a, 0x000000000000800a, 0x000000000000800a],
  (4u64)[0x800000008000000a, 0x800000008000000a, 0x800000008000000a, 0x800000008000000a],
  (4u64)[0x8000000080008081, 0x8000000080008081, 0x8000000080008081, 0x8000000080008081],
  (4u64)[0x8000000000008080, 0x8000000000008080, 0x8000000000008080, 0x8000000000008080],
  (4u64)[0x0000000080000001, 0x0000000080000001, 0x0000000080000001, 0x0000000080000001],
  (4u64)[0x8000000080008008, 0x8000000080008008, 0x8000000080008008, 0x8000000080008008]
};

u256 ROL56 = 0x181F1E1D1C1B1A191017161514131211080F0E0D0C0B0A090007060504030201;
u256 ROL8  = 0x1E1D1C1B1A19181F16151413121110170E0D0C0B0A09080F0605040302010007;

// C[x] = A[x,0] ^ A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
inline fn __theta_sum_4x_avx2(reg ptr u256[25] a) -> reg u256[5]
{
  inline int x y;
  reg u256[5] c;

  // C[x] = A[x, 0]
  for x=0 to 5
  { c[x] = a[x + 0]; }

  // C[x] ^= A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
  for y=1 to 5
  { for x=0 to 5
    { c[x] ^= a[x + y*5]; }
  }

  return c;
}

inline fn __rol_4x_avx2(reg u256[5] a, inline int x r, reg u256 r8 r56) -> reg u256[5]
{
	reg u256 t;

  if(r == 8)
  {	a[x] = #VPSHUFB_256(a[x], r8); }
  else { if(r == 56)
  { a[x] = #VPSHUFB_256(a[x], r56); }
  else
  { t     = #VPSLL_4u64(a[x], r);
	  a[x]  = #VPSRL_4u64(a[x], 64 - r);
	  a[x] |= t; }
  }

	return a; 
}

// D[x] = C[x-1] ^ ROT(C[x+1], 1) 
inline fn __theta_rol_4x_avx2(reg u256[5] c, reg u256 r8 r56) -> reg u256[5]
{
  inline int x;
  reg u256[5] d;

  for x = 0 to 5
  { // D[x] = C[x + 1]
    d[x] = c[(x + 1) % 5];

    // D[x] = ROT(D[x], 1)
    d = __rol_4x_avx2(d, x, 1, r8, r56);

    // D[x] ^= C[x-1]
    d[x] ^= c[(x - 1 + 5) % 5];
  }

  return d;
}


// B[x] = ROT( (A[x',y'] ^ D[x']), r[x',y'] ) with (x',y') = M^-1 (x,y)
//
// M = (0 1)  M^-1 = (1 3)  x' = 1x + 3y
//     (2 3)         (1 0)  y' = 1x + 0y
//
inline fn __rol_sum_4x_avx2(
  reg ptr u256[25] a,
  reg u256[5] d,
  inline int y,
  reg u256 r8 r56
) -> reg u256[5]
{
  inline int r x x_ y_;
  reg u256[5] b;

  for x = 0 to 5
  {
    x_ = (x + 3*y) % 5;
    y_ = x;
    r = __rhotates(x_, y_);

    // B[x] = A[x',y']
    b[x] = a[x_ + y_*5];

    // B[x] ^= D[x'];
    b[x] ^= d[x_];

    // B[x] = ROT( B[x], r[x',y'] );
    if(r != 0)
    { b = __rol_4x_avx2(b, x, r, r8, r56); }
  }

  return b;
}


// E[x, y] = B[x] ^ ( (!B[x+1]) & B[x+2] )
// -- when x and y are 0: E[0,0] ^= RC[i];
inline fn __set_row_4x_avx2(
  reg ptr u256[25] e,
  reg u256[5] b,
  inline int y,
  reg u256 rc
) -> reg ptr u256[25]
{
  inline int x x1 x2;
  reg u256 t;

  for x=0 to 5
  { 
    x1 = (x + 1) % 5;
    x2 = (x + 2) % 5;

    t = #VPANDN_256(b[x1], b[x2]);

    t ^= b[x];
    if( x==0 && y==0 ){ t ^= rc; }
    e[x + y*5] = t;
  }

  return e;
}


inline fn __round_4x_avx2(reg ptr u256[25] e a, reg u256 rc r8 r56) -> reg ptr u256[25]
{
  inline int y;
  reg u256[5] b c d;

  c = __theta_sum_4x_avx2(a);
  d = __theta_rol_4x_avx2(c, r8, r56);

  for y = 0 to 5
  { b = __rol_sum_4x_avx2(a, d, y, r8, r56);
    e = __set_row_4x_avx2(e, b, y, rc);
  }

  return e;
}


inline fn __keccakf1600_4x_avx2(reg ptr u256[25] a) -> reg ptr u256[25]
{
  reg ptr u256[24] RC;
  stack u256[25] s_e;
  reg ptr u256[25] e;
  reg u256 rc r8 r56;
  reg u64 c;

  e = s_e;
  RC = KECCAK1600_RC_4x;

  r8 = ROL8;
  r56 = ROL56;

  c = 0;
  while
  {
    rc = RC.[(int) c];
    e = __round_4x_avx2(e, a, rc, r8, r56);

    rc = RC.[(int) c + 32];
    a = __round_4x_avx2(a, e, rc, r8, r56);

    c += 64;
  } (c < (KECCAK_ROUNDS*32))

  return a;
}

fn _keccakf1600_4x_avx2(reg ptr u256[25] a) -> reg ptr u256[25]
{
  a = __keccakf1600_4x_avx2(a);
  return a;
}

// ////////////////////////////////////////////////////////////////////////////
// pack/unpack state

inline
fn __u256x4_4u64x4(reg u256 x0 x1 x2 x3) -> reg u256, reg u256, reg u256, reg u256 {
  // x0 = l00 l01  l02 l03
  // x1 = l10 l11  l12 l13
  // x2 = l20 l21  l22 l23
  // x3 = l30 l31  l32 l33
  reg u256 y0, y1, y2, y3;
  y0 = #VPUNPCKL_4u64(x0, x1);	// y0 = l00 l10  l02 l12
  y1 = #VPUNPCKH_4u64(x0, x1);	// y1 = l01 l11  l03 l13
  y2 = #VPUNPCKL_4u64(x2, x3);	// y2 = l20 l30  l22 l32
  y3 = #VPUNPCKH_4u64(x2, x3);	// y3 = l21 l31  l23 l33

  x0 = #VPERM2I128(y0, y2, 0x20);	// x0 = l00 l10  l20 l30
  x1 = #VPERM2I128(y1, y3, 0x20);	// x1 = l01 l11  l21 l31
  x2 = #VPERM2I128(y0, y2, 0x31);	// x2 = l02 l12  l22 l32
  x3 = #VPERM2I128(y1, y3, 0x31);	// x3 = l03 l13  l23 l33

  return x0, x1, x2, x3;
}

inline
fn __4u64x4_u256x4(reg u256 y0 y1 y2 y3) -> reg u256, reg u256, reg u256, reg u256 {
  // y0 = l00 l10  l20 l30
  // y1 = l01 l11  l21 l31
  // y2 = l02 l12  l22 l32
  // y3 = l03 l13  l23 l33
  reg u256 x0, x1, x2, x3;
  x0 = #VPERM2I128(y0, y2, 0x20);	// x0 = l00 l10  l02 l12
  x1 = #VPERM2I128(y1, y3, 0x20);	// x1 = l01 l11  l03 l13
  x2 = #VPERM2I128(y0, y2, 0x31);	// x2 = l20 l30  l22 l32
  x3 = #VPERM2I128(y1, y3, 0x31);	// x3 = l21 l31  l23 l33

  y0 = #VPUNPCKL_4u64(x0, x1);	// y0 = l00 l01  l02 l03
  y1 = #VPUNPCKH_4u64(x0, x1);	// y1 = l10 l11  l12 l13
  y2 = #VPUNPCKL_4u64(x2, x3);	// y2 = l20 l21  l22 l23
  y3 = #VPUNPCKH_4u64(x2, x3);	// y3 = l30 l31  l32 l33

  return y0, y1, y2, y3;
}

// state pack/unpack
inline
fn __st4x_pack(stack u64[25] st0 st1 st2 st3) -> stack u256[25] {
  inline int i;
  reg u256 x0, x1, x2, x3;
  reg u64 t0, t1, t2, t3;
  stack u256[25] st4x;
  for i = 0 to 6 {
    x0 = st0[u256 i];
    x1 = st1[u256 i];
    x2 = st2[u256 i];
    x3 = st3[u256 i];
    x0, x1, x2, x3 = __u256x4_4u64x4(x0, x1, x2, x3);
    st4x[4*i+0] = x0;
    st4x[4*i+1] = x1;
    st4x[4*i+2] = x2;
    st4x[4*i+3] = x3;
  }
  t0 = st0[24];
  t1 = st1[24];
  t2 = st2[24];
  t3 = st3[24];
  st4x[u64 4*24+0] = t0;
  st4x[u64 4*24+1] = t1;
  st4x[u64 4*24+2] = t2;
  st4x[u64 4*24+3] = t3;

  return st4x;
}

inline
fn __st4x_unpack(stack u256[25] st4x) -> stack u64[25], stack u64[25], stack u64[25], stack u64[25] {
  inline int i;
  reg u256 x0, x1, x2, x3;
  reg u64 t0, t1, t2, t3;
  stack u64[25] st0, st1, st2, st3;
  for i = 0 to 6 {
    x0 = st4x[4*i+0];
    x1 = st4x[4*i+1];
    x2 = st4x[4*i+2];
    x3 = st4x[4*i+3];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    st0[u256 i] = x0;
    st1[u256 i] = x1;
    st2[u256 i] = x2;
    st3[u256 i] = x3;
  }
  t0 = st4x[u64 4*24+0];
  t1 = st4x[u64 4*24+1];
  t2 = st4x[u64 4*24+2];
  t3 = st4x[u64 4*24+3];
  st0[24] = t0;
  st1[24] = t1;
  st2[24] = t2;
  st3[24] = t3;

  return st0, st1, st2, st3;
}


inline
fn __u64x2_u128(reg u64 x0 x1) -> reg u128 {
  reg u128 y;
  y = (128u) x0;
  y = #VPINSR_2u64(y, x1, 1);
  return y;
}

inline
fn __u64x4_u256(reg u64 x0 x1 x2 x3) -> reg u256 {
  reg u128 h l;
  reg u256 y;
  l = __u64x2_u128(x0, x1);
  h = __u64x2_u128(x2, x3);
  y = (2u128)[h, l];
  return y;
}


// ////////////////////////////////////////////////////////////////////////////

inline
fn __shake128_absorb4x_genmat(
  reg ptr u256[25] st4x,
  reg ptr u8[32] seed,
  reg u64 e0 e1 e2 e3)
  ->
  reg ptr u256[25]
{
  inline int i;
  reg u256 x0 x1 x2 x3;
  reg u64 t0, t1, t2, t3;

  x0 = seed[u256 0];
  x0, x1, x2, x3 = __u256x4_4u64x4(x0, x0, x0, x0);
  st4x[0] = x0;
  st4x[1] = x1;
  st4x[2] = x2;
  st4x[3] = x3;

  e0 ^= 0x1F0000;
  e1 ^= 0x1F0000;
  e2 ^= 0x1F0000;
  e3 ^= 0x1F0000;
  x0 = __u64x4_u256(e0, e1, e2, e3);
  st4x[4] = x0;

  x0 = #set0_256();
  x1 = shake_sep[u256 0];
  for i = 5 to 25 {
    if ( i == (SHAKE128_RATE / 8 - 1) ) {
      st4x[i] = x1;
    } else {
      st4x[i] = x0;
    }
  }

  return st4x;
}

inline
fn __shake128_absorb4x_34(
  reg ptr u256[25] st4x,
  reg ptr u8[34] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
  inline int i;
  reg u256 x0 x1 x2 x3;
  reg u64 t0, t1, t2, t3;

  x0 = m0[u256 0];
  x1 = m1[u256 0];
  x2 = m2[u256 0];
  x3 = m3[u256 0];
  x0, x1, x2, x3 = __u256x4_4u64x4(x0, x1, x2, x3);
  st4x[0] = x0;
  st4x[1] = x1;
  st4x[2] = x2;
  st4x[3] = x3;

  t0 = (64u) m0[u16 16];
  t1 = (64u) m1[u16 16];
  t2 = (64u) m2[u16 16];
  t3 = (64u) m3[u16 16];
  t0 ^= 0x1F0000;
  t1 ^= 0x1F0000;
  t2 ^= 0x1F0000;
  t3 ^= 0x1F0000;
  x0 = __u64x4_u256(t0, t1, t2, t3);
  st4x[4] = x0;

  x0 = #set0_256();
  x1 = shake_sep[u256 0];
  for i = 5 to 25 {
    if ( i == (SHAKE128_RATE / 8 - 1) ) {
      st4x[i] = x1;
    } else {
      st4x[i] = x0;
    }
  }

  return st4x;
}

/*
fn _shake128_absorb4x_34(
  reg ptr u256[25] s,
  reg ptr u8[34] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
	inline int i;
  reg u256 t0 t1;
  reg u16 t16;
	reg u64 t64;

  for i = 0 to 25
  {
    t0 = #set0_256();
    s[i] = t0;
  }

	for i = 0 to 4
  {
    t64 = m0[u64 i];
    s[u64 4 * i] ^= t64;
    t64 = m1[u64 i];
    s[u64 4 * i + 1] ^= t64;
    t64 = m2[u64 i];
    s[u64 4 * i + 2] ^= t64;
    t64 = m3[u64 i];
    s[u64 4 * i + 3] ^= t64;
  }

  t16 = m0.[u16 32];
  s[u16 64] ^= t16;
  s[u8 130] ^= 0x1F;

  t16 = m1.[u16 32];
  s[u16 68] ^= t16;
  s[u8 138] ^= 0x1F;

  t16 = m2.[u16 32];
  s[u16 72] ^= t16;
  s[u8 146] ^= 0x1F;

  t16 = m3.[u16 32];
  s[u16 76] ^= t16;
  s[u8 154] ^= 0x1F;

  t0 = shake_sep[u256 0];
  t1 = s[SHAKE128_RATE / 8 - 1];
  t0 = t0 ^ t1;
  s[SHAKE128_RATE / 8 - 1] = t0;

	return s;
}
*/

/*
inline
fn __shake128_squeezeblock4x(
  reg ptr u256[25] state,
  reg ptr u8[SHAKE128_RATE] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE]
{
  reg u256 t256;
  reg u128 t128;
  inline int i;

  state = _keccakf1600_4x_avx2(state);

	for i = 0 to (SHAKE128_RATE / 8) {
    t256 = state[i];
    t128 = (128u)t256;
		h0[u64 i] = #VMOVLPD(t128);
		h1[u64 i] = #VMOVHPD(t128);
    t128 = #VEXTRACTI128(t256, 1);
		h2[u64 i] = #VMOVLPD(t128);
		h3[u64 i] = #VMOVHPD(t128);
	}

  return state, h0, h1, h2, h3;
}
*/
inline
fn __shake128_squeezeblock_4x(
  reg ptr u256[25] st4x,
  reg ptr u8[SHAKE128_RATE] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE]
{
  reg u256 x0, x1, x2, x3;
  reg u128 t128_l, t128_h;
  inline int i;

  st4x = _keccakf1600_4x_avx2(st4x);

  for i = 0 to 5 {
    x0 = st4x[4*i+0];
    x1 = st4x[4*i+1];
    x2 = st4x[4*i+2];
    x3 = st4x[4*i+3];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    h0[u256 i] = x0;
    h1[u256 i] = x1;
    h2[u256 i] = x2;
    h3[u256 i] = x3;
  }

  x0 = st4x[20];
  t128_l = (128u) x0;
  t128_h = #VEXTRACTI128(x0, 1);
  h0[u64 20] = #VMOVLPD(t128_l);
  h1[u64 20] = #VMOVHPD(t128_l);
  h2[u64 20] = #VMOVLPD(t128_h);
  h3[u64 20] = #VMOVHPD(t128_h);

  return st4x, h0, h1, h2, h3;
}

inline
fn __shake128_squeeze3blocks_4x(
  reg ptr u256[25] st4x,
  reg ptr u8[512] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[512],
  reg ptr u8[512],
  reg ptr u8[512],
  reg ptr u8[512]
{
  reg u256 x0, x1, x2, x3;
  inline int i;

  st4x = _keccakf1600_4x_avx2(st4x);

  for i = 0 to 5 {
    x0 = st4x[4*i+0];
    x1 = st4x[4*i+1];
    x2 = st4x[4*i+2];
    x3 = st4x[4*i+3];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    h0[u256 i] = x0;
    h1[u256 i] = x1;
    h2[u256 i] = x2;
    h3[u256 i] = x3;
  }

  x0 = st4x[20];
  st4x = _keccakf1600_4x_avx2(st4x);
  x1 = st4x[0];
  x2 = st4x[1];
  x3 = st4x[2];
  x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
  h0[u256 5] = x0;
  h1[u256 5] = x1;
  h2[u256 5] = x2;
  h3[u256 5] = x3;

  for i = 0 to 4 {
    x0 = st4x[4*i+3];
    x1 = st4x[4*i+4];
    x2 = st4x[4*i+5];
    x3 = st4x[4*i+6];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    h0[u256 i+6] = x0;
    h1[u256 i+6] = x1;
    h2[u256 i+6] = x2;
    h3[u256 i+6] = x3;
  }

  x0 = st4x[19];
  x1 = st4x[20];
  st4x = _keccakf1600_4x_avx2(st4x);
  x2 = st4x[0];
  x3 = st4x[1];
  x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
  h0[u256 10] = x0;
  h1[u256 10] = x1;
  h2[u256 10] = x2;
  h3[u256 10] = x3;

  for i = 0 to 4 {
    x0 = st4x[4*i+2];
    x1 = st4x[4*i+3];
    x2 = st4x[4*i+4];
    x3 = st4x[4*i+5];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    h0[u256 i+11] = x0;
    h1[u256 i+11] = x1;
    h2[u256 i+11] = x2;
    h3[u256 i+11] = x3;
  }

  x0 = st4x[18];
  x1 = st4x[19];
  x2 = st4x[20];
  x3 = #set0_256();
  x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
  h0[u256 15] = x0;
  h1[u256 15] = x1;
  h2[u256 15] = x2;
  h3[u256 15] = x3;

  return st4x, h0, h1, h2, h3;
}



// ////////////////////////////////////////////////////////////////////////////

inline
fn __shake256_absorb4x_33(
  reg ptr u256[25] st4x,
  reg ptr u8[33] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
  inline int i;
  reg u256 x0 x1 x2 x3;
  reg u64 t0, t1, t2, t3;

  x0 = m0[u256 0];
  x1 = m1[u256 0];
  x2 = m2[u256 0];
  x3 = m3[u256 0];
  x0, x1, x2, x3 = __u256x4_4u64x4(x0, x1, x2, x3);
  st4x[0] = x0;
  st4x[1] = x1;
  st4x[2] = x2;
  st4x[3] = x3;

  t0 = (64u) m0[u8 32];
  t1 = (64u) m1[u8 32];
  t2 = (64u) m2[u8 32];
  t3 = (64u) m3[u8 32];
  t0 ^= 0x1F00;
  t1 ^= 0x1F00;
  t2 ^= 0x1F00;
  t3 ^= 0x1F00;
  x0 = __u64x4_u256(t0, t1, t2, t3);
  st4x[4] = x0;

  x0 = #set0_256();
  x1 = shake_sep[u256 0];
  for i = 5 to 25 {
    if ( i == (SHAKE256_RATE / 8 - 1) ) {
      st4x[i] = x1;
    } else {
      st4x[i] = x0;
    }
  }

  return st4x;
}

/*
fn _shake256_absorb4x_33(
  reg ptr u256[25] s,
  reg ptr u8[33] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
	inline int i;
  reg u256 t0 t1;
	reg u64 t64;
  reg u8 t8;

  for i = 0 to 25
  {
    t0 = #set0_256();
    s[i] = t0;
  }

	for i = 0 to 4
  {
    t64 = m0[u64 i];
    s[u64 4 * i] ^= t64;
    t64 = m1[u64 i];
    s[u64 4 * i + 1] ^= t64;
    t64 = m2[u64 i];
    s[u64 4 * i + 2] ^= t64;
    t64 = m3[u64 i];
    s[u64 4 * i + 3] ^= t64;
  }

  t8 = m0[32];
  s[u8 128] ^= t8;
  s[u8 129] ^= 0x1F;

  t8 = m1[32];
  s[u8 136] ^= t8;
  s[u8 137] ^= 0x1F;

  t8 = m2[32];
  s[u8 144] ^= t8;
  s[u8 145] ^= 0x1F;

  t8 = m3[32];
  s[u8 152] ^= t8;
  s[u8 153] ^= 0x1F;

  t0 = shake_sep[u256 0];
  t1 = s[SHAKE256_RATE / 8 - 1];
  t0 = t0 ^ t1;
  s[SHAKE256_RATE / 8 - 1] = t0;

	return s;
}
*/

inline
fn __shake256_squeezeblock4x(
  reg ptr u256[25] state,
  reg ptr u8[SHAKE256_RATE] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE]
{
  reg u256 t256;
  reg u128 t128;
  inline int i;

  state = _keccakf1600_4x_avx2(state);

	for i = 0 to (SHAKE256_RATE / 8) {
    t256 = state[i];
    t128 = (128u)t256;
		h0[u64 i] = #VMOVLPD(t128);
		h1[u64 i] = #VMOVHPD(t128);
    t128 = #VEXTRACTI128(t256, 1);
		h2[u64 i] = #VMOVLPD(t128);
		h3[u64 i] = #VMOVHPD(t128);
	}

  return state, h0, h1, h2, h3;
}

inline
fn __shake256_squeeze_128u8_4x(
  reg ptr u256[25] st4x,
  reg ptr u8[128] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[128],
  reg ptr u8[128],
  reg ptr u8[128],
  reg ptr u8[128]
{
  inline int i;
  reg u256 x0, x1, x2, x3;

  st4x = _keccakf1600_4x_avx2(st4x);

  for i = 0 to 4 {
    x0 = st4x[4*i+0];
    x1 = st4x[4*i+1];
    x2 = st4x[4*i+2];
    x3 = st4x[4*i+3];
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    h0[u256 i] = x0;
    h1[u256 i] = x1;
    h2[u256 i] = x2;
    h3[u256 i] = x3;
  }

  return st4x, h0, h1, h2, h3;
}
