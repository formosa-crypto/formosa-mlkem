
namespace OLD_KECCAK {
require "keccak_OLD/fips202.jinc"
require "keccak_OLD/fips202_4x.jinc"

inline fn _sha3_256A_M1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg u64 in
) -> reg ptr u8[32]
{ reg u64 inlen;
  inlen = 1184;
  out = _isha3_256(out, in, inlen);
  return out;
}

inline fn _shake256_M32__M32_M1088
( reg u64 out
, reg u64 in0 in1 // 32+MLKEM_INDCPA_CIPHERTEXTBYTES
)
{ _shake256_1120_32(out, in0, in1); }

inline fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ reg u256 t256;
  reg u8 t8;
  stack u8[33] in_s;
  reg ptr u8[33] in;
  in = in_s;
  t256 = seed[u256 0];
  in[u256 0] = t256;
  t8 = nonce[0];
  in[32] = t8;
  out = _shake256_128_33(out, in);
  return out;
}

inline fn _shake256x4_A128__A32_A1
( reg mut ptr u8[128] out0 out1 out2 out3
, reg const ptr u8[32] seed
, reg const ptr u8[4] nonce
) -> reg ptr u8[128] /* out0 */
   , reg ptr u8[128] /* out1 */
   , reg ptr u8[128] /* out2 */
   , reg ptr u8[128] /* out3 */
{ reg u256 t256;
  reg u8 t8;
  stack u8[33] in0 in1 in2 in3;
  stack u256[25] st_s;
  reg ptr u256[25] st;
  st = st_s;
  t256 = seed[u256 0];
  in0[u256 0] = t256;
  t8 = nonce[0];
  in0[32] = t8;
  t8 = nonce[1];
  in1[u256 0] = t256;
  in1[32] = t8;
  t8 = nonce[2];
  in2[u256 0] = t256;
  in2[32] = t8;
  t8 = nonce[3];
  in3[u256 0] = t256;
  in3[32] = t8;
  st = _shake256_absorb4x_33(st, in0, in1, in2, in3);
  st, out0, out1, out2, out3 = __shake256_squeezeblock4xTRANSITION(st, out0, out1, out2, out3);
  return out0, out1, out2, out3;
}

inline fn _sha3_256A_A32
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in
) -> reg ptr u8[32]
{ out = _isha3_256_32(out, in); return out; }

inline fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ out = _sha3_512_64(out, in); return out; }

inline fn _sha3_512A_A32
( reg mut ptr u8[64] out
, reg const ptr u8[32] in
) -> reg ptr u8[64]
{ out = _sha3_512_32(out, in); return out; }

} // OLD_KECCAK

namespace NEW_KECCAK {
require "mlkem_keccak_avx2.jinc"
}

inline fn _sha3_256A_M1184
( #spill_to_mmx reg mut ptr u8[32] out
, #spill_to_mmx reg u64 in
) -> reg ptr u8[32]
{ out = NEW_KECCAK::_sha3_256A_M1184(out, in); return out; }


inline fn _shake256_M32__M32_M1088
( reg u64 out
, reg u64 in0 in1 // 32+MLKEM_INDCPA_CIPHERTEXTBYTES
)
{ NEW_KECCAK::_shake256_M32__M32_M1088(out, in0, in1); }

inline fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ out = NEW_KECCAK::_shake256_A128__A32_A1(out, seed, nonce); return out; }

inline fn _shake256x4_A128__A32_A1
( reg mut ptr u8[128] out0 out1 out2 out3
, reg const ptr u8[32] seed
, reg const ptr u8[4] nonces
) -> reg ptr u8[128] /* out0 */
   , reg ptr u8[128] /* out1 */
   , reg ptr u8[128] /* out2 */
   , reg ptr u8[128] /* out3 */
{ out0, out1, out2, out3 = NEW_KECCAK::_shake256x4_A128__A32_A1(out0, out1, out2, out3, seed, nonces); return out0, out1, out2, out3; }

inline fn _sha3_256A_A32
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] in
) -> reg ptr u8[32]
{ out = NEW_KECCAK::_sha3_256A_A32(out, in); return out; }

inline fn _sha3_512A_A64
( reg mut ptr u8[64] out
, reg const ptr u8[64] in
) -> reg ptr u8[64]
{ out = NEW_KECCAK::_sha3_512A_A64(out, in); return out; }

inline fn _sha3_512A_A32
( reg mut ptr u8[64] out
, reg const ptr u8[32] in
) -> reg ptr u8[64]
{ out = NEW_KECCAK::_sha3_512A_A32(out, in); return out; }


// Only available on the new version!!!
inline fn _shake128_absorb_A32_A2
( reg const ptr u8[32] seed
, reg const ptr u8[2] pos
) -> reg u256[7]
{ reg u256[7] st; st = NEW_KECCAK::_shake128_absorb_A32_A2(seed, pos); return st; }

inline fn _shake128x4_absorb_A32_A2
( reg mut ptr u256[25] st
, reg const ptr u8[32] seed
, reg const ptr u8[8] pos
) -> reg ptr u256[25]
{ st = NEW_KECCAK::_shake128x4_absorb_A32_A2(st, seed, pos); return st; }

inline fn _shake128_squeeze3blocks
( reg mut ptr u8[536] buf
, reg u256[7] st 
) -> reg ptr u8[536]
{ buf = NEW_KECCAK::_shake128_squeeze3blocks( buf, st); return buf; }

inline fn _shake128_next_state
( reg mut ptr u8[536] buf
) -> reg ptr u8[536] /* buf */
{ buf = NEW_KECCAK::_shake128_next_state(buf); return buf; }

inline fn _shake128x4_squeeze3blocks
( reg mut ptr u256[25] st
, reg mut ptr u8[4*536] buf
) -> reg ptr u256[25]   /* st */
   , reg ptr u8[4*536] /* buf */
{ st, buf = NEW_KECCAK::_shake128x4_squeeze3blocks(st, buf); return st, buf; }
