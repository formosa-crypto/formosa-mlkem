require "params.jinc"
require "poly.jinc"
require "polyvec.jinc"
require "gen_matrix_globals.jinc"
require "../../common/avx2/gen_matrix.jinc"

fn _gen_matrix_avx2_nounpack
( reg mut ptr u16[MLKEM_K * MLKEM_K * MLKEM_N] matrix
, reg const ptr u8[32] rho
, #spill_to_mmx reg u64 transposed
) -> reg ptr u16[MLKEM_K * MLKEM_K * MLKEM_N]
{
  // local variables
  inline int i;
  stack u8[BUF_size * 4] buf_s;
  reg ptr u8[BUF_size * 4] buf;
  reg ptr u16[4*MLKEM_N] polx4;
  reg ptr u16[MLKEM_N] pol;
  reg u64 pos_entry;
  reg u16 rc;

  () = #spill(transposed);

  buf = buf_s;

  for i = 0 to 2
  {
    pos_entry = 8*i;
    polx4 = matrix[4*i*MLKEM_N:4*MLKEM_N];
    () = #unspill(transposed);
    polx4, buf = _gen_matrix_sample_four_polynomials(polx4, buf, rho, pos_entry, transposed);
    matrix[i*4*MLKEM_N:4*MLKEM_N] = polx4;
  }

  // sample the last one, (2,2), using single-lane code
  pol = matrix[8*MLKEM_N:MLKEM_N];
  rc = 0x0202;
  pol, buf[BUF_size * 0 : BUF_size] = __gen_matrix_sample_one_polynomial(pol, buf[BUF_size * 0 : BUF_size], rho, rc);

  matrix[8*MLKEM_N:MLKEM_N] = pol;

  return matrix;
}

#[sct="
{ ptr: transient, val: secret } × { ptr: transient, val: secret } × transient → { ptr: public, val: secret }
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_gen_matrix(
    #secret reg mut ptr u16[MLKEM_K * MLKEM_K * MLKEM_N] matrix,
    #secret reg const ptr u8[32] rho,
    #public #spill_to_mmx reg u64 transposed
) -> #secret reg ptr u16[MLKEM_K * MLKEM_K * MLKEM_N] {
   _ = #init_msf();
   transposed &= 1;
   matrix = _gen_matrix_avx2_nounpack(matrix,rho,transposed);
   return matrix;
}
