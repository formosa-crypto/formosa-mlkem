require "kem.jinc"

#[sct="
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } →
{ ptr: public, val: secret } ×
{ ptr: public, val: secret } ×
public
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_keypair_derand(
    #secret reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
    #secret reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key,
    #secret reg ptr u8[2*MLKEM_SYMBYTES] coins)
 -> #secret reg ptr u8[MLKEM_PUBLICKEYBYTES], #secret reg ptr u8[MLKEM_SECRETKEYBYTES], #public reg u64
requires{is_arr_init(coins,0,2*MLKEM_SYMBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_PUBLICKEYBYTES) && is_arr_init(result.1,0,MLKEM_SECRETKEYBYTES)}
{
  reg u64 r;

  _ = #init_msf();

  public_key, secret_key = __crypto_kem_keypair_jazz(public_key, secret_key, coins);

  ?{}, r = #set0();
  return public_key, secret_key, r;
}

#[sct="
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } →
{ ptr: public, val: secret } ×
{ ptr: public, val: secret } ×
public
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_enc_derand(
    #secret reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    #secret reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    #secret reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
    #secret reg ptr u8[MLKEM_SYMBYTES] coins)
    -> #secret reg ptr u8[MLKEM_CIPHERTEXTBYTES], #secret reg ptr u8[MLKEM_SYMBYTES], #public reg u64
requires{is_arr_init(coins,0,MLKEM_SYMBYTES) && is_arr_init(public_key,0,MLKEM_PUBLICKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(result.1,0,MLKEM_SYMBYTES)}
{
  reg u64 r;

  _ = #init_msf();

  public_key = public_key;

  ciphertext, shared_secret =__crypto_kem_enc_jazz(ciphertext, shared_secret, public_key, coins);

  ?{}, r = #set0();
  return ciphertext, shared_secret, r;
}

#[sct="
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } →
{ ptr: public, val: secret } ×
{ ptr: public, val: secret } ×
public
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_keypair(
    #secret reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key,
    #secret reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key)
 -> #secret reg ptr u8[MLKEM_PUBLICKEYBYTES], #secret reg ptr u8[MLKEM_SECRETKEYBYTES], #public reg u64
ensures{is_arr_init(result.0,0,MLKEM_PUBLICKEYBYTES) && is_arr_init(result.1,0,MLKEM_SECRETKEYBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES*2] randomness;
  reg ptr u8[MLKEM_SYMBYTES*2] randomnessp;

  _ = #init_msf();

  public_key = public_key;
  secret_key = secret_key;

  randomnessp = randomness;
  randomnessp = #randombytes(randomnessp);
  (public_key, secret_key) = __crypto_kem_keypair_jazz(public_key, secret_key, randomnessp);
  
  ?{}, r = #set0();
  return public_key, secret_key, r;
}

#[sct="
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } →
{ ptr: public, val: secret } ×
{ ptr: public, val: secret } ×
public
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_enc(
    #secret reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    #secret reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    #secret reg ptr u8[MLKEM_PUBLICKEYBYTES] public_key)
    -> #secret reg ptr u8[MLKEM_CIPHERTEXTBYTES], #secret reg ptr u8[MLKEM_SYMBYTES], #public reg u64
requires{is_arr_init(public_key,0,MLKEM_PUBLICKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(result.1,0,MLKEM_SYMBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES] randomness;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp;

  _ = #init_msf();

  ciphertext = ciphertext;
  shared_secret = shared_secret;
  public_key = public_key;

  randomnessp = randomness;
  randomnessp = #randombytes(randomnessp);

  (ciphertext, shared_secret) = __crypto_kem_enc_jazz(ciphertext, shared_secret, public_key, randomnessp);

  ?{}, r = #set0();
  return ciphertext, shared_secret, r;
}

#[sct="
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } ×
{ ptr: transient, val: secret } →
{ ptr: public, val: secret } ×
public
"]
export fn jade_kem_mlkem_mlkem768_amd64_avx2_dec(
    #secret reg ptr u8[MLKEM_SYMBYTES] shared_secret,
    #secret reg ptr u8[MLKEM_CIPHERTEXTBYTES] ciphertext,
    #secret reg ptr u8[MLKEM_SECRETKEYBYTES] secret_key)
    -> #secret reg ptr u8[MLKEM_SYMBYTES], #public reg u64
requires{is_arr_init(ciphertext,0,MLKEM_CIPHERTEXTBYTES) && is_arr_init(secret_key,0,MLKEM_SECRETKEYBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_SYMBYTES)}
{
  reg u64 r;

  _ = #init_msf();

  shared_secret = __crypto_kem_dec_jazz(shared_secret, ciphertext, secret_key);

  ?{}, r = #set0();
  return shared_secret, r;
}
